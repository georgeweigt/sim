;    Copyright (c) Microsoft Corporation.
;
;    Permission is hereby granted, free of charge, to any person obtaining a copy
;    of this software and associated documentation files (the "Software"), to deal
;    in the Software without restriction, including without limitation the rights
;    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;    copies of the Software, and to permit persons to whom the Software is
;    furnished to do so, subject to the following conditions:
;
;    The above copyright notice and this permission notice shall be included in all
;    copies or substantial portions of the Software.
;
;    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;    SOFTWARE

RAMLOC	EQU	$1000
ROMLOC	EQU	$d000

NUMLEV	EQU	23		;NUMBER OF STACK LEVELS RESERVED
				;BY AN EXPLICIT CALL TO "GETSTK".
STRSIZ	EQU	3		;# OF LOCS PER STRING DESCRIPTOR.
NUMTMP	EQU	3		;NUMBER OF STRING TEMPORARIES.
CONTW	EQU	15		;CHARACTER TO SUPPRESS OUTPUT.

BUFPAG	EQU	2
BUF	EQU	256*BUFPAG
BUFLEN	EQU	240
LINLEN	EQU	80
CLMWID	EQU	14
SKIP1	EQU	$24
SKIP2	EQU	$2C
ADDPRC	EQU	1
INTPRC	EQU	1
OUTCH	EQU	$FFF1
FGETS	EQU	$FFF3
STKEND	EQU	507

	ORG	0

START:	BSS	3		;INITIALIZE - SETUP CERTAIN LOCATIONS
				;AND DELETE FUNCTIONS IF NOT NEEDED,
				;AND CHANGE THIS TO "JMP READY"
				;IN CASE USER RESTARTS AT LOC ZERO.
RDYJSR:	BSS	3		;CHANGED TO "JMP STROUT" BY "INIT"
				;TO HANDLE ERRORS.
ADRAYI:	BSS	2		;STORE HERE THE ADDR OF THE
				;ROUTINE TO TURN THE FAC INTO A
				;TWO BYTE SIGNED INTEGER IN [Y,A]
ADRGAY:	BSS	2		;STORE HERE THE ADDR OF THE
				;ROUTINE TO CONVERT [Y,A] TO A FLOATING
				;POINT NUMBER IN THE FAC.
USRPOK:	BSS	3		;SET UP ORIG BY INIT.
;
; THIS IS THE "VOLATILE" STORAGE AREA AND NONE OF IT
; CAN BE KEPT IN ROM. ANY CONSTANTS IN THIS AREA CANNOT
; BE KEPT IN A ROM, BUT MUST BE LOADED IN BY THE 
; PROGRAM INSTRUCTIONS IN ROM.
;
; --- GENERAL RAM ---:
CHARAC:	BSS	1		;A DELIMITING CHARACTER.
INTEGR	EQU	CHARAC		;A ONE-BYTE INTEGER FROM "QINT".
ENDCHR:	BSS	1		;THE OTHER DELIMITING CHARACTER.
COUNT:	BSS	1		;A GENERAL COUNTER.

; --- FLAGS ---:
DIMFLG:	BSS	1		;IN GETTING A POINTER TO A VARIABLE
				;IT IS IMPORTANT TO REMEMBER WHETHER IT
				;IS BEING DONE FOR "DIM" OR NOT.
				;DIMFLG AND VALTYP MUST BE
				;CONSECUTIVE LOCATIONS.
KIMY	EQU	DIMFLG		;PLACE TO PRESERVE Y DURING OUT.
VALTYP:	BSS	1		;THE TYPE INDICATOR.
				;0=NUMERIC 1=STRING.
INTFLG:	BSS	1		;TELLS IF INTEGER.
DORES:	BSS	1		;WHETHER CAN OR CAN'T CRUNCH RES'D WORDS.
				;TURNED ON WHEN "DATA"
				;BEING SCANNED BY CRUNCH SO UNQUOTED
				;STRINGS WON'T BE CRUNCHED.
GARBFL	EQU	DORES		;WHETHER TO DO GARBAGE COLLECTION.
SUBFLG:	BSS	1		;FLAG WHETHER SUB'D VARIABLE ALLOWED.
				;"FOR" AND USER-DEFINED FUNCTION
				;POINTER FETCHING TURN
				;THIS ON BEFORE CALLING "PTRGET"
				;SO ARRAYS WON'T BE DETECTED.
				;"STKINI" AND "PTRGET" CLEAR IT.
				;ALSO DISALLOWS INTEGERS THERE.
INPFLG:	BSS	1		;FLAGS WHETHER WE ARE DOING "INPUT"
				;OR "READ".
TANSGN:	BSS	1		;USED IN DETERMINING SIGN OF TANGENT.
CNTWFL:	BSS	1		;SUPPRESS OUTPUT FLAG.
				;NON-ZERO MEANS SUPPRESS.
				;RESET BY "INPUT", READY AND ERRORS.
				;COMPLEMENTED BY INPUT OF ^O.

; --- RAM DEALING WITH TERMINAL HANDLING ---:
CHANNL:	BSS	1		;HOLDS CHANNEL NUMBER.
TRMPOS:	BSS	1		;POSITION OF TERMINAL CARRIAGE.
LINWID:	BSS	1		;LENGTH OF LINE (WIDTH).
NCMWID:	BSS	1		;POSITION BEYOND WHICH THERE ARE
				;NO MORE FIELDS.
LINNUM:	BSS	1		;LOCATION TO STORE LINE NUMBER BEFORE BUF
				;SO THAT "BLTUC" CAN STORE IT ALL AWAY AT ONCE.
	BSS	1		;A COMMA (PRELOAD OR FROM ROM)
				;USED BY INPUT STATEMENT SINCE THE
				;DATA POINTER ALWAYS STARTS ON A
				;COMMA OR TERMINATOR.

; --- STORAGE FOR TEMPORARY THINGS ---:
TEMPPT:	BSS	1		;POINTER AT FIRST FREE TEMP DESCRIPTOR.
				;INITIALIZED TO POINT TO TEMPST.
LASTPT:	BSS	2		;POINTER TO LAST-USED STRING TEMPORARY.
TEMPST:	BSS	STRSIZ*NUMTMP	;STORAGE FOR NUMTMP TEMP DESCRIPTORS.
INDEX1:	BSS	2		;INDEXES.
INDEX	EQU	INDEX1
INDEX2:	BSS	2
RESHO:	BSS	1		;RESULT OF MULTIPLIER AND DIVIDER.
RESMOH:	BSS	1		;ONE MORE BYTE.
RESMO:	BSS	1
RESLO:	BSS	1
ADDEND	EQU	RESMO		;TEMPORARY USED BY "UMULT".
	BSS	1		;OVERFLOW FOR RES.

; --- POINTERS INTO DYNAMIC DATA STRUCTURES ---;
TXTTAB:	BSS	2		;POINTER TO BEGINNING OF TEXT.
				;DOESN'T CHANGE AFTER BEING
				;SETUP BY "INIT".
VARTAB:	BSS	2		;POINTER TO START OF SIMPLE
				;VARIABLE SPACE.
				;UPDATED WHENEVER THE SIZE OF THE
				;PROGRAM CHANGES, SET TO [TXTTAB]
				;BY "SCRATCH" ("NEW").
ARYTAB:	BSS	2		;POINTER TO BEGINNING OF ARRAY
				;TABLE.
				;INCREMENTED BY 6 WHENEVER
				;A NEW SIMPLE VARIABLE IS FOUND, AND
				;SET TO [VARTAB] BY "CLEARC".
STREND:	BSS	2		;END OF STORAGE IN USE.
				;INCREASED WHENEVER A NEW ARRAY
				;OR SIMPLE VARIABLE IS ENCOUNTERED.
				;SET TO [VARTAB] BY "CLEARC".
FRETOP:	BSS	2		;TOP OF STRING FREE SPACE.
FRESPC:	BSS	2		;POINTER TO NEW STRING.
MEMSIZ:	BSS	2		;HIGHEST LOCATION IN MEMORY.

; --- LINE NUMBERS AND TEXTUAL POINTERS ---:
CURLIN:	BSS	2		;CURRENT LINE #.
				;SET TO 0,255 FOR DIRECT STATEMENTS.
OLDLIN:	BSS	2		;OLD LINE NUMBER (SETUP BY ^C,"STOP"
				;OR "END" IN A PROGRAM).
POKER	EQU	LINNUM		;SET UP LOCATION USED BY POKE.
				;TEMPORARY FOR INPUT AND READ CODE
OLDTXT:	BSS	2		;OLD TEXT POINTER.
				;POINTS AT STATEMENT TO BE EXEC'D NEXT.
DATLIN:	BSS	2		;DATA LINE # -- REMEMBER FOR ERRORS.
DATPTR:	BSS	2		;POINTER TO DATA. INITIALIZED TO POINT
				;AT THE ZERO IN FRONT OF [TXTTAB]
				;BY "RESTORE" WHICH IS CALLED BY "CLEARC".
				;UPDATED BY EXECUTION OF A "READ".
INPPTR:	BSS	2		;THIS REMEMBERS WHERE INPUT IS COMING FROM.

; --- STUFF USED IN EVALUATIONS ---:
VARNAM:	BSS	2		;VARIABLE'S NAME IS STORED HERE.
VARPNT:	BSS	2		;POINTER TO VARIABLE IN MEMORY.
FDECPT	EQU	VARPNT		;POINTER INTO POWER OF TENS OF "FOUT".
FORPNT:	BSS	2		;A VARIABLE'S POINTER FOR "FOR" LOOPS
				;AND "LET" STATEMENTS.
LSTPNT	EQU	FORPNT		;PNTR TO LIST STRING.
ANDMSK	EQU	FORPNT		;THE MASK USED BY WAIT FOR ANDING.
EORMSK	EQU	FORPNT+1	;THE MASK FOR EORING IN WAIT.
OPPTR:	BSS	2		;POINTER TO CURRENT OP'S ENTRY IN "OPTAB".
VARTXT	EQU	OPPTR		;POINTER INTO LIST OF VARIABLES.
OPMASK:	BSS	1		;MASK CREATED BY CURRENT OPERATOR.
DOMASK	EQU	TANSGN		;MASK IN USE BY RELATION OPERATIONS.
DEFPNT:	BSS	2		;POINTER USED IN FUNCTION DEFINITION.
GRBPNT	EQU	DEFPNT		;ANOTHER USED IN GARBAGE COLLECTION.
DSCPNT:	BSS	2		;POINTER TO A STRING DESCRIPTOR.
	BSS	1		;FOR TEMPF3.
FOUR6:	BSS	STRSIZ		;VARIABLE CONSTANT USED BY GARB COLLECT.

; --- ET CETERA ---:
JMPER:	BSS	3		;JMP	60000
SIZE	EQU	JMPER+1
OLDOV	EQU	JMPER+2		;THE OLD OVERFLOW.
TEMPF3	EQU	DEFPNT		;A THIRD FAC TEMPORARY (4 BYTES).
TEMPF1:
	BSS	1		;FOR TEMPF1S EXTRA BYTE.
HIGHDS:	BSS	2		;DESINATION OF HIGHEST ELEMENT IN BLT.
HIGHTR:	BSS	2		;SOURCE OF HIGHEST ELEMENT TO MOVE.
TEMPF2:
	BSS	1		;FOR TEMPF2S EXTRA BYTE.
LOWDS:	BSS	2		;LOCATION OF LAST BYTE TRANSFERRED INTO.
LOWTR:	BSS	2		;LAST THING TO MOVE IN BLT.
ARYPNT	EQU	HIGHDS		;A POINTER USED IN ARRAY BUILDING.
GRBTOP	EQU	LOWTR		;A POINTER USED IN GARBAGE COLLECTION.
DECCNT	EQU	LOWDS		;NUMBER OF PLACES BEFORE DECIMAL POINT.
TENEXP	EQU	LOWDS+1		;HAS A DPT BEEN INPUT?
DPTFLG	EQU	LOWTR		;BASE TEN EXPONENT.
EXPSGN	EQU	LOWTR+1		;SIGN OF BASE TEN EXPONENT.

; --- THE FLOATING ACCUMULATOR ---:
FAC:
FACEXP:	BSS	1
FACHO:	BSS	1		;MOST SIGNIFICANT BYTE OF MANTISSA.
FACMOH:	BSS	1		;ONE MORE.
FACMO:	BSS	1		;MIDDLE ORDER OF MANTISSA.
FACLO:	BSS	1		;LEAST SIG BYTE OF MANTISSA.
FACSGN:	BSS	1		;SIGN OF FAC (0 OR -1) WHEN UNPACKED.
SGNFLG:	BSS	1		;SIGN OF FAC IS PRESERVED BERE BY "FIN".
DEGREE	EQU	SGNFLG		;A COUNT USED BY POLYNOMIALS.
DSCTMP	EQU	FAC		;THIS IS WHERE TEMP DESCS ARE BUILT.
INDICE	EQU	FACMO		;INDICE IS SET UP HERE BY "QINT".
BITS:	BSS	1		;SOMETHING FOR "SHIFTR" TO USE.

; --- THE FLOATING ARGUMENT (UNPACKED) ---:
ARGEXP:	BSS	1
ARGHO:	BSS	1
ARGMOH:	BSS	1
ARGMO:	BSS	1
ARGLO:	BSS	1
ARGSGN:	BSS	1

ARISGN:	BSS	1		;A SIGN REFLECTING THE RESULT.
FACOV:	BSS	1		;OVERFLOW BYTE OF THE FAC.
STRNG1	EQU	ARISGN		;POINTER TO A STRING OR DESCRIPTOR.

FBUFPT:	BSS	2		;POINTER INTO FBUFFR USED BY FOUT.
BUFPTR	EQU	FBUFPT		;POINTER TO BUF USED BY "CRUNCH".
STRNG2	EQU	FBUFPT		;POINTER TO STRING OR DESC.
POLYPT	EQU	FBUFPT		;POINTER INTO POLYNOMIAL COEFFICIENTS.
CURTOL	EQU	FBUFPT		;ABSOLUTE LINEAR INDEX IS FORMED HERE.
; THIS CODE GETS CHANGED THROUGHOUT EXECUTION.
; IT IS MADE TO BE FAST THIS WAY.
; ALSO, [X] AND [Y] ARE NOT DISTURBED
;
; "CHRGET" USING [TXTPTR] AS THE CURRENT TEXT PNTR
; FETCHES A NEW CHARACTER INTO ACCA AFTER INCREMENTING [TXTPTR]
; AND SETS CONDITION CODES ACCORDING TO WHAT'S IN ACCA.
;	NOT C=	NUMERIC	  ("0" THRU "9")
;	Z=	":" OR END-OF-LINE (A NULL)
;
; [ACCA] = NEW CHAR.
; [TXTPTR]=[TXTPTR]+1
;
; THE FOLLOWING EXISTS IN ROM IF ROM EXISTS AND IS LOADED
; DOWN HERE BY INIT. OTHERWISE IT IS JUST LOADED INTO THIS
; RAM LIKE ALL THE REST OF RAM IS LOADED.
;
CHRGET:	BSS	2		;INC	CHRGET+7
	BSS	2		;BNE	CHRGOT
	BSS	2		;INC	CHRGET+8
CHRGOT:	BSS	3		;LDA	60000
TXTPTR:	EQU	CHRGOT+1
	BSS	2		;CMPI	" "
	BSS	2		;BEQ	CHRGET
QNUM:	BSS	2		;CMPI	":"
	BSS	2		;BCS	CHRRTS
	BSS	1		;SEC
	BSS	2		;SBCI	"0"
	BSS	1		;SEC
	BSS	2		;SBCI	256-"0"
CHRRTS:	BSS	1		;RTS

RNDX:	BSS	1		;LOADED OR FROM ROM.
	BSS	1		;THE INITIAL RANDOM NUMBER.
	BSS	1
	BSS	1
	BSS	1		;ONE MORE BYTE.

	ORG	255		;PAGE 1 STUFF COMING UP.

LOFBUF:	BSS	1		;THE LOW FAC BUFFER. COPYABLE.
;---  PAGE ZERO/ONE BOUNDARY ---.
				;MUST HAVE 13 CONTIGUOUS BYTES.
FBUFFR:	BSS	3*ADDPRC+13	;BUFFER FOR "FOUT".
				;ON PAGE 1 SO THAT STRING IS NOT COPIED.

;STACK IS LOCATED HERE. IE FROM THE END OF FBUFFR TO STKEND.

	ORG	ROMLOC
	JMP	INIT

STMDSP:	WORD	END-1		;1
	WORD	FOR-1		;2
	WORD	NEXT-1		;3
	WORD	DATA-1		;4
	WORD	INPUT-1		;5
	WORD	DIM-1		;6
	WORD	READ-1		;7
	WORD	LET-1		;8
	WORD	GOTO-1		;9
	WORD	RUN-1		;10
	WORD	IF-1		;11
	WORD	RESTOR-1	;12
	WORD	GOSUB-1		;13
	WORD	RETURN-1	;14
	WORD	REM-1		;15
	WORD	STOP-1		;16
	WORD	ONGOTO-1	;17
	WORD	FNWAIT-1	;18
	WORD	DEF-1		;19
	WORD	POKE-1		;20
	WORD	PRINT-1		;21
	WORD	CONT-1		;22
	WORD	LIST-1		;23
	WORD	CLEAR-1		;24
	WORD	GET-1		;25
	WORD	SCRATH-1	;26

FUNDSP:	WORD	SGN
	WORD	INT
	WORD	ABS
USRLOC:	WORD	USRPOK
	WORD	FRE
	WORD	POS
	WORD	SQR
	WORD	RND
	WORD	LOG
	WORD	EXP
	WORD	FCERR
	WORD	FCERR
	WORD	FCERR
	WORD	FCERR
	WORD	PEEK
	WORD	LEN
	WORD	STR
	WORD	VAL
	WORD	ASC
	WORD	CHR
	WORD	LEFT
	WORD	RIGHT
	WORD	MID
OPTAB:	BYTE	121
	WORD	FADDT-1
	BYTE	121
	WORD	FSUBT-1
	BYTE	123
	WORD	FMULTT-1
	BYTE	123
	WORD	FDIVT-1
	BYTE	127
	WORD	FPWRT-1
	BYTE	80
	WORD	ANDOP-1
	BYTE	70
	WORD	OROP-1
NEGTAB:	BYTE	125
	WORD	NEGOP-1
NOTTAB:	BYTE	90
	WORD	NOTOP-1
PTDORL:	BYTE	100		;PRECEDENCE.
	WORD	DOREL-1		;OPERATOR ADDRESS.
;
; TOKENS FOR RESERVED WORDS ALWAYS HAVE THE MOST
; SIGNIFICANT BIT ON.
; THE LIST OF RESERVED WORDS:
;
RESLST:	BYTE	"E","N","D"+128			;1
ENDTK:	EQU	127+1
	BYTE	"F","O","R"+128			;2
FORTK:	EQU	127+2
	BYTE	"N","E","X","T"+128		;3
	BYTE	"D","A","T","A"+128		;4
DATATK:	EQU	127+4
	BYTE	"I","N","P","U","T"+128		;5
	BYTE	"D","I","M"+128			;6
	BYTE	"R","E","A","D"+128		;7
	BYTE	"L","E","T"+128			;8
	BYTE	"G","O","T","O"+128		;9
GOTOTK:	EQU	127+9
	BYTE	"R","U","N"+128			;10
	BYTE	"I","F"+128			;11
	BYTE	"R","E","S","T","O","R","E"+128	;12
	BYTE	"G","O","S","U","B"+128		;13
GOSUTK:	EQU	127+13
	BYTE	"R","E","T","U","R","N"+128	;14
	BYTE	"R","E","M"+128			;15
REMTK:	EQU	127+15
	BYTE	"S","T","O","P"+128		;16
	BYTE	"O","N"+128			;17
	BYTE	"W","A","I","T"+128		;18
	BYTE	"D","E","F"+128			;19
	BYTE	"P","O","K","E"+128		;20
	BYTE	"P","R","I","N","T"+128		;21
PRINTK:	EQU	127+21
	BYTE	"C","O","N","T"+128		;22
	BYTE	"L","I","S","T"+128		;23
	BYTE	"C","L","E","A","R"+128		;24
	BYTE	"G","E","T"+128			;25
	BYTE	"N","E","W"+128			;26
SCRATK:	EQU	127+26
; END OF COMMAND LIST.
	BYTE	"T","A","B","("+128		;27
TABTK:	EQU	127+27
	BYTE	"T","O"+128			;28
TOTK:	EQU	127+28
	BYTE	"F","N"+128			;29
FNTK:	EQU	127+29
	BYTE	"S","P","C","("+128		;30
SPCTK:	EQU	127+30
	BYTE	"T","H","E","N"+128		;31
THENTK:	EQU	127+31
	BYTE	"N","O","T"+128			;32
NOTTK:	EQU	127+32
	BYTE	"S","T","E","P"+128		;33
STEPTK:	EQU	127+33
	BYTE	"+"+128				;34
PLUSTK:	EQU	127+34
	BYTE	"-"+128				;35
MINUTK:	EQU	127+35
	BYTE	"*"+128				;36
	BYTE	"/"+128				;37
	BYTE	"^"+128				;38
	BYTE	"A","N","D"+128			;39
	BYTE	"O","R"+128			;40
	BYTE	">"+128				;41
GREATK:	EQU	127+41
	BYTE	"="+128				;42
EQULTK:	EQU	127+42
	BYTE	"<"+128				;43
LESSTK:	EQU	127+43
;
; NOTE DANGER OF ONE RESERVED WORD BEING A PART
; OF ANOTHER:
; IE . . IF 2 GREATER THAN F OR T=5 THEN...
; WILL NOT WORK!!! SINCE "FOR" WILL BE CRUNCHED!!
; IN ANY CASE MAKE SURE THE SMALLER WORD APPEARS
; SECOND IN THE RESERVED WORD TABLE ("INP" AND "INPUT")
; ANOTHER EXAMPLE: IF T OR Q THEN ... "TO" IS CRUNCHED
;
	BYTE	"S","G","N"+128			;44
ONEFUN:	EQU	127+44
	BYTE	"I","N","T"+128			;45
	BYTE	"A","B","S"+128			;46
	BYTE	"U","S","R"+128			;47
	BYTE	"F","R","E"+128			;48
	BYTE	"P","O","S"+128			;49
	BYTE	"S","Q","R"+128			;50
	BYTE	"R","N","D"+128			;51
	BYTE	"L","O","G"+128			;52
	BYTE	"E","X","P"+128			;53
	BYTE	"C","O","S"+128			;54
	BYTE	"S","I","N"+128			;55
	BYTE	"T","A","N"+128			;56
	BYTE	"A","T","N"+128			;57
	BYTE	"P","E","E","K"+128		;58
	BYTE	"L","E","N"+128			;59
	BYTE	"S","T","R","$"+128		;60
	BYTE	"V","A","L"+128			;61
	BYTE	"A","S","C"+128			;62
	BYTE	"C","H","R","$"+128		;63
LASNUM:	EQU	127+63		;NUMBER OF LAST FUNCTION
				;THAT TAKES ONE ARG
	BYTE	"L","E","F","T","$"+128		;64
	BYTE	"R","I","G","H","T","$"+128	;65
	BYTE	"M","I","D","$"+128		;66
	BYTE	"G","O"+128			;67
GOTK:	EQU	127+67
	BYTE	0		;MARKS END OF RESERVED WORD LIST

; NOTE: THIS ERROR COUNT TECHNIQUE WILL NOT WORK IF THERE ARE MORE
; THAN 256 CHARACTERS OF ERROR MESSAGES
ERRTAB:	BYTE	"NEXT WITHOUT FO","R"+128
ERRNF:	EQU	0
ERRSN:	EQU	$-ERRTAB
	BYTE	"SYNTA","X"+128
ERRRG:	EQU	$-ERRTAB
	BYTE	"RETURN WITHOUT GOSU","B"+128
ERROD:	EQU	$-ERRTAB
	BYTE	"OUT OF DAT","A"+128
ERRFC:	EQU	$-ERRTAB
	BYTE	"ILLEGAL QUANTIT","Y"+128
ERROV:	EQU	$-ERRTAB
	BYTE	"OVERFLO","W"+128
ERROM:	EQU	$-ERRTAB
	BYTE	"OUT OF MEMOR","Y"+128
ERRUS:	EQU	$-ERRTAB
	BYTE	"UNDEF'D STATEMEN","T"+128
ERRBS:	EQU	$-ERRTAB
	BYTE	"BAD SUBSCRIP","T"+128
ERRDD:	EQU	$-ERRTAB
	BYTE	"REDIM'D ARRA","Y"+128
ERRDV0:	EQU	$-ERRTAB
	BYTE	"DIVISION BY ZER","O"+128
ERRID:	EQU	$-ERRTAB
	BYTE	"ILLEGAL DIREC","T"+128
ERRTM:	EQU	$-ERRTAB
	BYTE	"TYPE MISMATC","H"+128
ERRLS:	EQU	$-ERRTAB
	BYTE	"STRING TOO LON","G"+128
ERRST:	EQU	$-ERRTAB
	BYTE	"FORMULA TOO COMPLE","X"+128
ERRCN:	EQU	$-ERRTAB
	BYTE	"CAN'T CONTINU","E"+128
ERRUF:	EQU	$-ERRTAB
	BYTE	"UNDEF'D FUNCTIO","N"+128

;
; NEEDED FOR MESSAGES IN ALL VERSIONS.
;
ERR:	BYTE	" ERROR"
	BYTE	0
INTXT:	BYTE	" IN "
	BYTE	0
REDDY:	BYTE	13,10
	BYTE	"OK"
	BYTE	13,10
	BYTE	0
BRKTXT:	BYTE	13,10
	BYTE	"BREAK"
	BYTE	0
;
; FIND A "FOR" ENTRY ON THE STACK VIA "VARPNT".
;
FORSIZ:	EQU	2*ADDPRC+16
FNDFOR:	TSX			;LOAD XREG WITH STK PNTR.
	;REPEAT  4,<INX>	;IGNORE ADR(NEWSTT) AND RTS ADDR.
	INX
	INX
	INX
	INX
	;
FFLOOP:	LDA	257,X		;GET STACK ENTRY.
	CMP	#FORTK		;IS IT A "FOR" TOKEN?
	BNE	FFRTS		;NO, NO "FOR" LOOPS WITH THIS PNTR.
	LDA	FORPNT+1	;GET HIGH.
	BNE	CMPFOR
	LDA	258,X		;PNTR IS ZERO, SO ASSUME THIS ONE.
	STA	FORPNT
	LDA	259,X
	STA	FORPNT+1
CMPFOR:	CMP	259,X
	BNE	ADDFRS		;NOT THIS ONE.
	LDA	FORPNT		;GET DOWN.
	CMP	258,X
	BEQ	FFRTS		;WE GOT IT! WE GOT IT!
ADDFRS:	TXA
	CLC			;ADD 16 TO X.
	ADC	#FORSIZ
	TAX			;RESULT BACK INTO X.
	BNE	FFLOOP
FFRTS:	RTS			;RETURN TO CALLER.

;
; THIS IS THE BLOCK TRANSFER ROUTINE.
; IT MAKES SPACE BY SHOVING EVERYTHING FORWARD.
;
; ON ENTRY:
; [Y,A]=[HIGHDS]    (FOR REASON).
; [HIGHDS]= DESTINATION OF [HIGH ADDRESS].
; [LOWTR]= LOWEST ADDR TO BE TRANSFERRED.
; [HIGHTR]= HIGHEST ADDR TO BE TRANSFERRED.
;
; A CHECK IS MADE TO ASCERTAIN THAT A REASONABLE
; AMOUNT OF SPACE REMAINS BETWEEN THE BOTTOM
; OF THE STRINGS AND THE HIGHEST LOCATION TRANSFERRED INTO.
;
; ON EXIT:
; [LOWTR] ARE UNCHANGED.
; [HIGHTR]=[LOWTR]-200 OCTAL.
; [HIGHDS]=LOWEST ADDR TRANSFERRED INTO MINUS 200 OCTAL.
;
BLTU:	JSR	REASON		;ASCERTAIN THAT STRING SPACE WON'T
				;BE OVERRUN.
	;STWD	STREND
	STA	STREND
	STY	STREND+1
BLTUC:	SEC			;PREPARE TO SUBTRACT.
	LDA	HIGHTR
	SBC	LOWTR		;COMPUTE NUMBER OF THINGS TO MOVE.
	STA	INDEX		;SAVE FOR LATER.
	TAY
	LDA	HIGHTR+1
	SBC	LOWTR+1
	TAX			;PUT IT IN A COUNTER REGISTER.
	INX			;SO THAT COUNTER ALGORITHM WORKS.
	TYA			;SEE IF LOW PART OF COUNT IS ZERO.
	BEQ	DECBLT		;YES, GO START MOVING BLOCKS.
	LDA	HIGHTR		;NO, MUST MODIFY BASE ADDR.
	SEC
	SBC	INDEX		;BORROW IS OFF SINCE [HIGHTR].GT.[LOWTR].
	STA	HIGHTR		;SAVE MODIFIED BASE ADDR.
	BCS	BLT1		;IF NO BORROW, GO SHOVE IT.
	DEC	HIGHTR+1	;BORROW IMPLIES SUB 1 FROM HIGH ORDER.
	SEC
BLT1:	LDA	HIGHDS		;MOD BASE OF DEST ADDR.
	SBC	INDEX
	STA	HIGHDS
	BCS	MOREN1		;NO BORROW.
	DEC	HIGHDS+1	;DECREMENT HIGH ORDER BYTE.
	BCC	MOREN1		;ALWAYS SKIP.
BLTLP:	;LDADY	HIGHTR		;FETCH BYTE TO MOVE
	LDA	(HIGHTR),Y
	;
	;STADY	HIGHDS		;MOVE IT IN, MOVE IT OUT.
	STA	(HIGHDS),Y
	;
MOREN1:	DEY
	BNE	BLTLP
	;LDADY	HIGHTR		;MOVE LAST OF THE BLOCK.
	LDA	(HIGHTR),Y
	;
	;STADY	HIGHDS
	STA	(HIGHDS),Y
	;
DECBLT:	DEC	HIGHTR+1
	DEC	HIGHDS+1	;START ON NEW BLOCKS.
	DEX
	BNE	MOREN1
	RTS			;RETURN TO CALLER.
;
; THIS ROUTINE IS USED TO ASCERTAIN THAT A GIVEN
; NUMBER OF LOCS REMAIN AVAILABLE FOR THE STACK.
;    THE CALL IS:
;	LDAI	NUMBER OF 2-BYTE ENTRIES NEEDED.
;	JSR	GETSTK
;
; THIS ROUTINE MUST BE CALLED BY ANY ROUTINE WHICH PUTS
; AN ARBITRARY AMOUNT OF STUFF ON THE STACK,
; I.E., ANY RECURSIVE ROUTINE LIKE "FRMEVL".
; IT IS ALSO CALLED BY ROUTINES SUCH AS "GOSUB" AND "FOR"
; WHICH MAKE PERMANENT ENTRIES ON THE STACK.
;
; ROUTINES WHICH MERELY USE AND FREE UP THE GUARANTEED
; NUMLEV LOCATIONS NEED NOT CALL THIS.
;
;
; ON EXIT:
;    [A] AND [X] HAVE BEEN MODIFIED.
;
GETSTK:	ASL	A		;MULT [A] BY 2. NB, CLEARS C BIT.
	ADC	#(2*NUMLEV)+(3*ADDPRC)+13	;MAKE SURE 2*NUMLEV+13 LOCS
				;(13 BECAUSE OF FBUFFR)
	BCS	OMERR		;WILL REMAIN IN STACK.
	STA	INDEX
	TSX			;GET STACKED.
	CPX	INDEX		;COMPARE.
	BCC	OMERR		;IF STACK.LE.INDEX1, OM.
	RTS
;
; [Y,A] IS A CERTAIN ADDRESS. "REASON" MAKES SURE
; IT IS LESS THAN [FRETOP].
;
REASON:	CPY	FRETOP+1
	BCC	REARTS
	BNE	TRYMOR		;GO GARB COLLECT.
	CMP	FRETOP
	BCC	REARTS
TRYMOR:	PHA
	LDX	#8+ADDPRC	;IF TEMPF2 HAS ZERO IN BETWEEN.
	TYA
REASAV:	PHA
	LDA	HIGHDS-1,X	;SAVE HIGHDS ON STACK.
	DEX
	BPL	REASAV		;PUT 8 OF THEM ON STK.
	JSR	GARBA2		;GO GARB COLLECT.
	LDX	#256-8-ADDPRC
REASTO:	PLA
	STA	HIGHDS+8+ADDPRC,X	;RESTORE AFTER GARB COLLECT.
	INX
	BMI	REASTO
	PLA
	TAY
	PLA			;RESTORE A AND Y.
	CPY	FRETOP+1	;COMPARE HIGHS
	BCC	REARTS
	BNE	OMERR		;HIGHER IS BAD.
	CMP	FRETOP		;AND THE LOWS.
	BCS	OMERR
REARTS:	RTS

OMERR:	LDX	#ERROM
ERROR:
	LSR	CNTWFL		;FORCE OUTPUT.
ERRCRD:	JSR	CRDO		;OUTPUT CRLF.
	JSR	OUTQST		;PRINT A QUESTION MARK
GETERR:	LDA	ERRTAB,X
	PHA
	AND	#127		;GET RID OF HIGH BIT.
	JSR	OUTDO		;OUTPUT IT.
	INX
	PLA			;LAST CHAR OF MESSAGE?
	BPL	GETERR		;NO. GO GET NEXT AND OUTPUT IT.
TYPERR:	JSR	STKINI		;RESET THE STACK AND FLAGS.
	;LDWDI	ERR		;GET PNTR TO " ERROR".
	LDA	#ERR
	LDY	#ERR>>8
	;
ERRFIN:	JSR	STROUT		;OUTPUT IT.
	LDY	CURLIN+1
	INY			;WAS NUMBER 64000?
	BEQ	READY		;YES, DON'T TYPE LINE NUMBER.
	JSR	INPRT
READY:
	LSR	CNTWFL		;TURN OUTPUT BACK ON IF SUPRESSED
	;LDWDI	REDDY		;SAY "OK".
	LDA	#REDDY
	LDY	#REDDY>>8
	;
	JSR	RDYJSR		;OR GO TO INIT IF INIT ERROR.
MAIN:	JSR	INLIN		;GET A LINE FROM TERMINAL.
	;STXY	TXTPTR
	STX	TXTPTR
	STY	TXTPTR+1
	;
	JSR	CHRGET
	TAX			;SET ZERO FLAG BASED ON [A]
				;THIS DISTINGUISHES ":" AND 0
	BEQ	MAIN		;IF BLANK LINE, GET ANOTHER.
	LDX	#255		;SET DIRECT LINE NUMBER.
	STX	CURLIN+1
	BCC	MAIN1		;IS A LINE NUMBER. NOT DIRECT.
	JSR	CRUNCH		;COMPACTIFY.
	JMP	GONE		;EXECUTE IT.
MAIN1:	JSR	LINGET		;READ LINE NUMBER INTO "LINNUM".
	JSR	CRUNCH
	STY	COUNT		;RETAIN CHARACTER COUNT.
	JSR	FNDLIN
	BCC	NODEL		;NO MATCH, SO DON'T DELETE.
	LDY	#1
	;LDADY	LOWTR
	LDA	(LOWTR),Y
	;
	STA	INDEX1+1
	LDA	VARTAB
	STA	INDEX1
	LDA	LOWTR+1		;SET TRANSFER TO.
	STA	INDEX2+1
	LDA	LOWTR
	DEY
	;SBCDY	LOWTR		;COMPUTE NEGATIVE LENGTH.
	SBC	(LOWTR),Y
	;
	CLC
	ADC	VARTAB		;COMPUTE NEW VARTAB.
	STA	VARTAB
	STA	INDEX2		;SET LOW OF TRANS TO.
	LDA	VARTAB+1
	ADC	#255
	STA	VARTAB+1	;COMPUTE HIGH OF VARTAB.
	SBC	LOWTR+1		;COMPUTE NUMBER OF BLOCKS TO MOVE.
	TAX
	SEC
	LDA	LOWTR
	SBC	VARTAB		;COMPUTE OFFSET.
	TAY
	BCS	QDECT1		;IF VARTAB.LE.LOWTR,
	INX			;DECR DUE TO CARRY, AND
	DEC	INDEX2+1	;DECREMENT STORE SO CARRY WORKS.
QDECT1:	CLC
	ADC	INDEX1
	BCC	MLOOP
	DEC	INDEX1+1
	CLC			;FOR LATER ADCQ
MLOOP:	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	;STADY	INDEX2
	STA	(INDEX2),Y
	;
	INY
	BNE	MLOOP		;BLOCK DONE?
	INC	INDEX1+1
	INC	INDEX2+1
	DEX
	BNE	MLOOP		;DO ANOTHER BLOCK. ALWAYS.
NODEL:	JSR	RUNC		;RESET ALL VARIABLE INFO SO GARBAGE
				;COLLECTION CAUSED BY REASON WILL WORK
	JSR	LNKPRG		;FIX UP THE LINKS
	LDA	BUF		;SEE IF ANYTHNG THERE
	BEQ	MAIN
	CLC
	LDA	VARTAB
	STA	HIGHTR		;SETUP HIGHTR.
	ADC	COUNT		;ADD LENGTH OF LINE TO INSERT.
	STA	HIGHDS		;THIS GIVES DEST ADDR.
	LDY	VARTAB+1
	STY	HIGHTR+1	;SAME FOR HIGH ORDERS.
	BCC	NODELC
	INY
NODELC:	STY	HIGHDS+1
	JSR	BLTU
	;LDWD	LINNUM
	LDA	LINNUM
	LDY	LINNUM+1
	;
	;STWD	BUF-2
	STA	BUF-2
	STY	BUF-1
	;
	;LDWD	STREND
	LDA	STREND
	LDY	STREND+1
	;
	;STWD	VARTAB
	STA	VARTAB
	STY	VARTAB+1
	;
	LDY	COUNT
	DEY
STOLOP:	LDA	BUF-4,Y
	;STADY	LOWTR
	STA	(LOWTR),Y
	;
	DEY
	BPL	STOLOP
FINI:	JSR	RUNC		;DO CLEAR & SET UP STACK.
				;AND SET [TXTPTR] TO [TXTTAB]-1.
	JSR	LNKPRG		;FIX UP PROGRAM LINKS
	JMP	MAIN
LNKPRG:	;LDWD	TXTTAB		;SET [INDEX] TO [TXTTAB].
	LDA	TXTTAB
	LDY	TXTTAB+1
	;
	;STWD	INDEX
	STA	INDEX
	STY	INDEX+1
	;
	CLC
;
; CHEAD GOES THROUGH PROGRAM STORAGE AND FIXES
; UP ALL THE LINKS. THE END OF EACH LINE IS FOUND
; BY SEARCHING FOR THE ZERO AT THE END.
; THE DOUBLE ZERO LINK IS USED TO DETECT THE END OF THE PROGRAM.
;
CHEAD:	LDY	#1
	;LDADY	INDEX		;ARRIVED AT DOUBLE ZEROES?
	LDA	(INDEX),Y
	;
	BEQ	LNKRTS
	LDY	#4
CZLOOP:	INY			;THERE IS AT LEAST ONE BYTE.
	;LDADY	INDEX
	LDA	(INDEX),Y
	;
	BNE	CZLOOP		;NO, CONTINUE SEARCHING.
	INY			;GO ONE BEYOND.
	TYA
	ADC	INDEX
	TAX
	LDY	#0
	;STADY	INDEX
	STA	(INDEX),Y
	;
	LDA	INDEX+1
	ADC	#0
	INY
	;STADY	INDEX
	STA	(INDEX),Y
	;
	STX	INDEX
	STA	INDEX+1
	BCC	CHEAD		;ALWAYS BRANCHES.
LNKRTS:	RTS
;
; THIS IS THE LINE INPUT ROUTINE.
; IT READS CHARACTERS INTO BUF USING BACKARROW (UNDERSCORE, OR
; SHIFT O) AS THE DELETE CHARACTER AND @ AS THE 
; LINE DELETE CHARACTER. IF MORE THAN BUFLEN CHARACTERS
; ARE TYPED, NO ECHOING IS DONE UNTIL A BACKARROW OR @ OR CR
; IS TYPED. CONTROL-G WILL BE TYPED FOR EACH EXTRA CHARACTER.
; THE ROUTINE IS ENTERED AT INLIN.
;
INLIN:	JSR	FGETS
	LDA	#0
	LDX	#BUF-1
	LDY	#(BUF-1)>>8
	RTS
;
; ALL "RESERVED" WORDS ARE TRANSLATED INTO SINGLE
; BYTES WITH THE MSB ON. THIS SAVES SPACE AND TIME 
; BY ALLOWING FOR TABLE DISPATCH DURING EXECUTION.
; THEREFORE ALL STATEMENTS APPEAR TOGETHER IN THE
; RESERVED WORD LIST IN THE SAME ORDER THEY
; APPEAR IN STMDSP.
;
				;THE AMOUNT TO OFFSET THE LOW BYTE
				;OF THE TEXT POINTER TO GET TO BUF
				;AFTER TXTPTR HAS BEEN SETUP TO POINT INTO BUF
BUFOFS:	EQU	(BUF/256)*256
CRUNCH:	LDX	TXTPTR		;SET SOURCE POINTER.
	LDY	#4		;SET DESTINATION OFFSET.
	STY	DORES		;ALLOW CRUNCHING.
KLOOP:	LDA	BUFOFS,X
CMPSPC:	CMP	#" "		;IS IT A SPACE TO SAVE?
	BEQ	STUFFH		;YES, GO SAVE IT.
	STA	ENDCHR		;IF IT'S A QUOTE, THIS WILL
				;STOP LOOP WHEN OTHER QUOTE APPEARS.
	CMP	#34		;QUOTE SIGN?
	BEQ	STRNG		;YES, DO SPECIAL STRING HANDLING.
	BIT	DORES		;TEST FLAG.
	BVS	STUFFH		;NO CRUNCH, JUST STORE.
	CMP	#"?"		;A QMARK?
	BNE	KLOOP1
	LDA	#PRINTK		;YES, STUFF A "PRINT" TOKEN.
	BNE	STUFFH		;ALWAYS GO TO STUFFH.
KLOOP1:	CMP	#"0"		;SKIP NUMERICS.
	BCC	MUSTCR
	CMP	#60		;":" AND ";" ARE ENTERED STRAIGHTAWAY.
	BCC	STUFFH
MUSTCR:	STY	BUFPTR		;SAVE BUFFER POINTER.
	LDY	#0		;LOAD RESLST POINTER.
	STY	COUNT		;ALSO CLEAR COUNT.
	DEY
	STX	TXTPTR		;SAVE TEXT POINTER FOR LATER USE.
	DEX
RESER:	INY
RESPUL:	INX
RESCON:	LDA	BUFOFS,X
	SEC			;PREPARE TO SUBSTARCT.
	SBC	RESLST,Y	;CHARACTERS EQUAL?
	BEQ	RESER		;YES, CONTINUE SEARCH.
	CMP	#128		;NO BUT MAYBE THE END IS HERE.
	BNE	NTHIS		;NO, TRULY UNEQUAL.
	ORA	COUNT
GETBPT:	LDY	BUFPTR		;GET BUFFER PNTR.
STUFFH:	INX
	INY
	STA	BUF-5,Y
	LDA	BUF-5,Y
	BEQ	CRDONE		;NULL IMPLIES END OF LINE.
	SEC			;PREPARE TO SUBSTARCT.
	SBC	#":"		;IS IT A ":"?
	BEQ	COLIS		;YES, ALLOW CRUNCHING AGAIN.
	CMP	#DATATK-":"	;IS IT A DATATK?
	BNE	NODATT		;NO, SEE IF IT IS REM TOKEN.
COLIS:	STA	DORES		;SETUP FLAG.
NODATT:	SEC			;PREP TO SBCQ
	SBC	#REMTK-":"	;REM ONLY STOPS ON NULL.
	BNE	KLOOP		;NO, CONTINUE CRUNCHING.
	STA	ENDCHR		;REM STOPS ONLY ON NULL, NOT : OR ".
STR1:	LDA	BUFOFS,X
	BEQ	STUFFH		;YES, END OF LINE, SO DONE.
	CMP	ENDCHR		;END OF GOBBLE?
	BEQ	STUFFH		;YES, DONE WITH STRING.
STRNG:	INY			;INCREMENT BUFFER POINTER.
	STA	BUF-5,Y
	INX
	BNE	STR1		;PROCESS NEXT CHARACTER.
NTHIS:	LDX	TXTPTR		;RESTORE TEXT POINTER.
	INC	COUNT		;INCREMENT RES WORD COUNT.
NTHIS1:	INY
	LDA	RESLST-1,Y	;GET RES CHARACTER.
	BPL	NTHIS1		;END OF ENTRY?
	LDA	RESLST,Y	;YES. IS IT THE END?
	BNE	RESCON		;NO, TRY THE NEXT WORD.
	LDA	BUFOFS,X	;YES, END OF TABLE. GET 1ST CHR.
	BPL	GETBPT		;STORE IT AWAY (ALWAYS BRANCHES).
CRDONE:	STA	BUF-3,Y		;SO THAT IF THIS IS A DIR STATEMENT
				;ITS END WILL LOOK LIKE END OF PROGRAM.
	DEC	TXTPTR+1
	LDA	#(BUF&255)-1	;MAKE TXTPTR POINT TO
	STA	TXTPTR		;CRUNCHED LINE.
LISTRT: RTS			;RETURN TO CALLER.
;
; FNDLIN SEARCHES THE PROGRAM TEXT FOR THE LINE
; WHOSE NUMBER IS PASSED IN "LINNUM".
; THERE ARE TWO POSSIBLE RETURNS:
;
;	1) CARRY SET.
;	   LOWTR POINTS TO THE LINK FIELD IN THE LINE
;	   WHICH IS THE ONE SEARCHED FOR.
;
;	2) CARRY NOT SET.
;	   LINE NOT FOUND. [LOWTR] POINTS TO THE LINE IN THE
;	   PROGRAM GREATER THAN THE ONE SOUGHT AFTER.
;
FNDLIN: ;LDWX	TXTTAB		;LOAD [X,A] WITH [TXTTAB]
	LDA	TXTTAB
	LDX	TXTTAB+1
	;
FNDLNC: LDY	#1
	;STWX	LOWTR		;STORE [X,A] INTO LOWTR
	STA	LOWTR
	STX	LOWTR+1
	;
	;LDADY	LOWTR		;SEE IF LINK IS 0
	LDA	(LOWTR),Y
	;
	BEQ	FLINRT
	INY
	INY
	LDA	LINNUM+1	;COMP HIGH ORDERS OF LINE NUMBERS.
	;CMPDY	LOWTR
	CMP	(LOWTR),Y
	;
	BCC	FLNRTS		;NO SUCH LINE NUMBER.
	BEQ	FNDLO1
	DEY
	BNE	AFFRTS		;ALWAYS BRANCH.
FNDLO1: LDA	LINNUM
	DEY
	;CMPDY	LOWTR		;COMPARE LOW ORDERS.
	CMP	(LOWTR),Y
	;
	BCC	FLNRTS		;NO SUCH NUMBER.
	BEQ	FLNRTS		;GO TIT.
AFFRTS: DEY
	;LDADY	LOWTR		;FETCH LINK.
	LDA	(LOWTR),Y
	;
	TAX
	DEY
	;LDADY	LOWTR
	LDA	(LOWTR),Y
	;
	BCS	FNDLNC		;ALWAYS BRANCHES.
FLINRT: CLC			;C MAY BE HIGH.
FLNRTS: RTS			;RETURN TO CALLER.
;
; THE "NEW" COMMAND CLEARS THE PROGRAM TEXT AS WELL
; AS VARIABLE SPACE.
;
SCRATH: BNE	FLNRTS		;MAKE SURE THERE IS A TERMINATOR.
SCRTCH: LDA	#0		;GET A CLEARER.
	TAY			;SET UP INDEX.
	;STADY	TXTTAB		;CLEAR	FIRST LINK.
	STA	(TXTTAB),Y
	;
	INY
	;STADY	TXTTAB
	STA	(TXTTAB),Y
	;
	LDA	TXTTAB
	CLC
	ADC	#2
	STA	VARTAB		;SETUP [VARTAB].
	LDA	TXTTAB+1
	ADC	#0
	STA	VARTAB+1
RUNC:	JSR	STXTPT
	LDA	#0		;SET ZERO FLAG
;
; THIS CODE IS FOR THE CLEAR COMMAND.
;
CLEAR:	BNE	STKRTS		;SYNTAX ERROR IF NO TERMINATOR.
;
; CLEAR INITIALIZES THE VARIABLE AND
; ARRAY SPACE BY RESETING ARYTAB (THE END OF SIMPLE VARIABLE SPACE)
; AND STREND (THE END OF ARRAY STORAGE). IT FALLS INTO "STKINI"
; WHICH RESETS THE STACK. 
;
CLEARC: ;LDWD	MEMSIZ		;FREE UP STRING SPACE.
	LDA	MEMSIZ
	LDY	MEMSIZ+1
	;
	;STWD	FRETOP
	STA	FRETOP
	STY	FRETOP+1
	;
	;LDWD	VARTAB		;LIBERATE THE
	LDA	VARTAB
	LDY	VARTAB+1
	;
	;STWD	ARYTAB		;VARIABLES AND
	STA	ARYTAB
	STY	ARYTAB+1
	;
	;STWD	STREND		;ARRAYS.
	STA	STREND
	STY	STREND+1
	;
FLOAD:	JSR	RESTOR		;RESTORE DATA.
;
; STKINI RESETS THE STACK POINTER ELIMINATING
; GOSUB AND FOR CONTEXT. STRING TEMPORARIES ARE FREED
; UP, SUBFLG IS RESET. CONTINUING IS PROHIBITED.
; AND A DUMMY ENTRY IS LEFT AT THE BOTTOM OF THE STACK SO "FNDFOR" WILL ALWAYS
; FIND A NON-"FOR" ENTRY AT THE BOTTOM OF THE STACK.
;
STKINI: LDX	#TEMPST		;INITIALIZE STRING TEMPORARIES.
	STX	TEMPPT
	PLA			;SETUP RETURN ADDRESS.
	TAY
	PLA
	LDX	#STKEND-257
	TXS
	PHA
	TYA
	PHA
	LDA	#0
	STA	OLDTXT+1	;DISALLOWING CONTINUING
	STA	SUBFLG		;ALLOW SUBSCRIPTS.
STKRTS: RTS

STXTPT: CLC
	LDA	TXTTAB
	ADC	#255
	STA	TXTPTR
	LDA	TXTTAB+1
	ADC	#255
	STA	TXTPTR+1	;SETUP TEXT POINTER.
	RTS

LIST:	BCC	GOLST		;IT IS A DIGIT.
	BEQ	GOLST		;IT IS A TERMINATOR.
	CMP	#MINUTK		;DASH PRECEDING?
	BNE	STKRTS		;NO, SO SYNTAX ERROR.
GOLST:	JSR	LINGET		;GET LINE NUMBER INTO NUMLIN.
	JSR	FNDLIN		;FIND LINE .GE. [NUMLIN].
	JSR	CHRGOT		;GET LAST CHARACTER.
	BEQ	LSTEND		;IF END OF LINE, # IS THE END.
	CMP	#MINUTK		;DASH?
	BNE	FLNRTS		;IF NOT, SYNTAX ERROR.
	JSR	CHRGET		;GET NEXT CHAR.
	JSR	LINGET		;GET END #.
	BNE	FLNRTS		;IF NOT TERMINATOR, ERROR.
LSTEND: PLA
	PLA			;GET RID OF "NEWSTT" RTS ADDR.
	LDA	LINNUM		;SEE IF IT WAS EXISTENT.
	ORA	LINNUM+1
	BNE	LIST4		;IT WAS TYPED.
	LDA	#255
	STA	LINNUM
	STA	LINNUM+1	;MAKE IT HUGE.
LIST4:	LDY	#1
	;LDADY	LOWTR		;IS LINK ZERO?
	LDA	(LOWTR),Y
	;
	BEQ	GRODY		;YES, GO TO READY.
	JSR	ISCNTC		;LISTEN FOR CONT-C.
	JSR	CRDO		;PRINT CRLF TO START WITH.
	INY
	;LDADY	LOWTR
	LDA	(LOWTR),Y
	;
	TAX
	INY
	;LDADY	LOWTR		;GET LINE NUMBER.
	LDA	(LOWTR),Y
	;
	CMP	LINNUM+1	;SEE IF BEYOND LAST.
	BNE	TSTDUN		;GO DETERMINE RELATION.
	CPX	LINNUM		;WAS EQUAL SO TEST LOW ORDER.
	BEQ	TYPLIN		;EQUAL, SO LIST IT.
TSTDUN: BCS	GRODY		;IF LINE IS GR THAN LAST, THEN DUNE.
TYPLIN: STY	LSTPNT
	JSR	LINPRT		;PRINT AS INT WITHOUT LEADING SPACE.
	LDA	#" "		;ALWAYS PRINT SPACE AFTER NUMBER.
PRIT4:	LDY	LSTPNT		;GET POINTER TO LINE BACK.
	AND	#127
PLOOP:	JSR	OUTDO		;PRINT CHAR.
PLOOP1: INY
	BEQ	GRODY		;IF WE HAVE PRINTED 256 CHARACTERS
				;THE PROGRAM MUST BE MISFORMATED IN
				;MEMORY DUE TO A BAD LOAD OR BAD
				;HARDWARE. LET THE GUY RECOVER
	;LDADY	LOWTR		;GET NEXT CHAR. IS IT ZERO?
	LDA	(LOWTR),Y
	;
	BNE	QPLOP		;YES. END OF LINE.
	TAY
	;LDADY	LOWTR
	LDA	(LOWTR),Y
	;
	TAX
	INY
	;LDADY	LOWTR
	LDA	(LOWTR),Y
	;
	STX	LOWTR
	STA	LOWTR+1
	BNE	LIST4		;BRANCH IF SOMETHING TO LIST.
GRODY:	JMP	READY
				;IS IT A TOKEN?
QPLOP:	BPL	PLOOP		;NO, HEAD FOR PRINTER.
	SEC
	SBC	#127		;GET RID OF SIGN BIT AND ADD 1.
	TAX			;MAKE IT A COUNTER.
	STY	LSTPNT		;SAVE POINTER TO LINE.
	LDY	#255		;LOOK AT RES'D WORD LIST.
RESRCH: DEX			;IS THIS THE RES'D WORD?
	BEQ	PRIT3		;YES, GO TOSS IT UP..
RESCR1: INY
	LDA	RESLST,Y	;END OF ENTRY?
	BPL	RESCR1		;NO, CONTINUE PASSING.
	BMI	RESRCH
PRIT3:	INY
	LDA	RESLST,Y
	BMI	PRIT4		;END OF RESERVED WORD.
	JSR	OUTDO		;PRINT IT.
	BNE	PRIT3		;END OF ENTRY? NO, TYPE REST.

;
; A "FOR" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
;
; LOW ADDRESS
;	TOKEN (FORTK) 1 BYTE
;	A POINTER TO THE LOOP VARIABLE 2 BYTES
;	THE STEP 4+ADDPRC BYTES
;	A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
;	THE UPPER VALUE 4+ADDPRC BYTES
;	THE LINE NUMBER OF THE "FOR" STATEMENT 2 BYTES
;	A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
; HIGH ADDRESS
;
; TOTAL 16+2*ADDPRC BYTES.
;

FOR:	LDA	#128		;DON'T RECOGNIZE
	STA	SUBFLG		;SUBSCRIPTED VARIABLES.
	JSR	LET		;READ THE VARIABLE AND ASSIGN IT
				;THE CORRECT INITIAL VALUE AND STORE
				;A POINTER TO THE VARIABLE IN VARPNT.
	JSR	FNDFOR		;PNTR IS IN VARPNT, AND FORPNT.
	BNE	NOTOL		;IF NO MATCH, DON'T ELIMINATE ANYTHING.
	TXA			;MAKE IT ARITHMETICAL.
	ADC	#FORSIZ-3	;ELIMINATE ALMOST ALL.
	TAX			;NOTE C=1, THEN PLA, PLA.
	TXS			;MANIFEST.
NOTOL:	PLA			;GET RID OF NEWSTT RETURN ADDRESS
	PLA			;IN CASE THIS IS A TOTALLY NEW ENTRY.
	LDA	#8+ADDPRC
	JSR	GETSTK		;MAKE SURE 16 BYTES ARE AVAILABLE.
	JSR	DATAN		;GET A COUNT IN [Y] OF THE NUMBER OF
				;CHACRACTERS LEFT IN THE "FOR" STATEMENT
				;[TXTPTR] IS UNAFFECTED.
	CLC			;PREP TO ADD.
	TYA			;SAVE IT FOR PUSHING.
	ADC	TXTPTR
	PHA
	LDA	TXTPTR+1
	ADC	#0
	PHA
	;PSHWD	CURLIN		;PUT LINE NUMBER ON STACK.
	LDA	CURLIN+1
	PHA
	LDA	CURLIN
	PHA
	;
	;SYNCHK	TOTK		;"TO" IS NECESSARY.
	LDA	#TOTK
	JSR	SYNCHR
	;
	JSR	CHKNUM		;VALUE MUST BE A NUMBER.
	JSR	FRMNUM		;GET UPPER VALUE INTO FAC.
	LDA	FACSGN		;PACK FAC.
	ORA	#127
	AND	FACHO
	STA	FACHO		;SET PACKED SIGN BIT.
	;LDWDI	LDFONE
	LDA	#LDFONE
	LDY	#LDFONE>>8
	;STWD	INDEX1
	STA	INDEX1
	STY	INDEX1+1
	JMP	FORPSH		;PUT FAC ONTO STACK, PACKED.
LDFONE: ;LDWDI	FONE		;PUT 1.0 INTO FAC.
	LDA	#FONE
	LDY	#FONE>>8
	JSR	MOVFM
	JSR	CHRGOT
	CMP	#STEPTK		;A STEP IS GIVEN?
	BNE	ONEON		;NO. ASSUME 1.0.
	JSR	CHRGET		;YES. ADVANCE POINTER.
	JSR	FRMNUM		;READ THE STEP.
ONEON:	JSR	SIGN		;GET SIGN IN ACCA.
	JSR	PUSHF		;PUSH FAC ONTO STACK (THRU A).
	;PSHWD	FORPNT		;PUT PNTR TO VARIABLE ON STACK.
	LDA	FORPNT+1
	PHA
	LDA	FORPNT
	PHA
	;
NXTCON: LDA	#FORTK		;PUT A FORTK ONTO STACK.
	PHA
;	BNE	NEWSTT		;SIMULATE BNE TO NEWSTT. JUST FALL IN.
;
; BACK HERE FOR NEW STATEMENT. CHARACTER POINTED TO BY TXTPTR
; IS ":" OR END-OF-LINE. THE ADDRESS OF THIS LOC IS LEFT
; ON THE STACK WHEN A STATEMENT IS EXECUTED SO THAT
; IT CAN MERELY DO A RTS WHEN IT IS DONE.
;
NEWSTT:
	JSR	ISCNTC		;LISTEN FOR CONTROL-C.
	;LDWD	TXTPTR		;LOOK AT CURRENT CHARACTER.
	LDA	TXTPTR
	LDY	TXTPTR+1
	;
	CPY	#BUFPAG		;SEE IF IT WAS DIRECT BY CHECK FOR BUF'S PAGE NUMBER
	BEQ	DIRCON
	;STWD	OLDTXT		;SAVE IN CASE OF RESTART BY INPUT.
	STA	OLDTXT
	STY	OLDTXT+1
	;
DIRCON:
	LDY	#0
	;LDADY	TXTPTR
	LDA	(TXTPTR),Y
	;
	BNE	MORSTS		;NOT NULL -- CHECK WHAT IT IS
	LDY	#2		;LOOK AT LINK.
	;LDADY	TXTPTR		;IS LINK 0?
	LDA	(TXTPTR),Y
	;
	CLC		;CLEAR CARRY FOR ENDCON AND MATH THAT FOLLOWS
	;JEQ	ENDCON		;YES - RAN OFF THE END.
	BNE	$+5
	JMP	ENDCON
	;
	INY			;PUT LINE NUMBER IN CURLIN.
	;LDADY	TXTPTR
	LDA	(TXTPTR),Y
	;
	STA	CURLIN
	INY
	;LDADY	TXTPTR
	LDA	(TXTPTR),Y
	;
	STA	CURLIN+1
	TYA
	ADC	TXTPTR
	STA	TXTPTR
	BCC	GONE
	INC	TXTPTR+1
GONE:	JSR	CHRGET		;GET THE STATEMENT TYPE.
	JSR	GONE3
	JMP	NEWSTT
GONE3:	BEQ	ISCRTS		;IF TERMINATOR, TRY AGAIN.
				;NO NEED TO SET UP CARRY SINCE IT WILL
				;BE ON IF NON-NUMERIC AND NUMERICS
				;WILL CAUSE A SYNTAX ERROR LIKE THEY SHOULD
GONE2:	SBC	#ENDTK		;" ON ... GOTO AND GOSUB" COME HERE.
	BCC	GLET
	CMP	#SCRATK-ENDTK+1
	BCS	SNERRX		;SOME RES'D WORD BUT NOT
				;A STATEMENT RES'D WORD.
	ASL	A		;MULTIPLY BY TWO.
	TAY			;MAKE AN INDEX.
	LDA	STMDSP+1,Y
	PHA
	LDA	STMDSP,Y
	PHA			;PUT DISP ADDR ONTO STACK.
	JMP	CHRGET
GLET:	JMP	LET		;MUST BE A LET
MORSTS: CMP	#":"
	BEQ	GONE		;IF A ":" CONTINUE STATEMENT
SNERR1: JMP	SNERR		;NEITHER 0 OR ":" SO SYNTAX ERROR
SNERRX: CMP	#GOTK-ENDTK
	BNE	SNERR1
	JSR	CHRGET		;READ IN THE CHARACTER AFTER "GO "
	;SYNCHK	TOTK
	LDA	#TOTK
	JSR	SYNCHR
	;
	JMP	GOTO

RESTOR: SEC
	LDA	TXTTAB
	SBC	#1
	LDY	TXTTAB+1
	BCS	RESFIN
	DEY
RESFIN: ;STWD	DATPTR		;READ FINISHES COME TO "RESFIN".
	STA	DATPTR
	STY	DATPTR+1
	;
ISCRTS: RTS

ISCNTC:	RTS			;FIXME

STOP:	BCS	STOPC		;MAKE [C] NONZERO AS A FLAG.
END:	CLC
STOPC:	BNE	CONTRT		;RETURN IF NOT CONT-C OR
				;IF NO TERMINATOR FOR STOP OR END.
				;[C]=0 SO WILL NOT PRINT "BREAK".
	;LDWD	TXTPTR
	LDA	TXTPTR
	LDY	TXTPTR+1
	;
	LDX	CURLIN+1
	BEQ	DIRIS
	;STWD	OLDTXT
	STA	OLDTXT
	STY	OLDTXT+1
	;
STPEND: ;LDWD	CURLIN
	LDA	CURLIN
	LDY	CURLIN+1
	;STWD	OLDLIN
	STA	OLDLIN
	STY	OLDLIN+1
DIRIS:	PLA			;POP OFF NEWSTT ADDR.
	PLA
ENDCON:	;LDWDI	BRKTXT
	LDA	#BRKTXT
	LDY	#BRKTXT>>8
	;
	LDX	#0
	STX	CNTWFL
	BCC	GORDY		;CARRY CLEAR SO DON'T PRINT "BREAK".
	JMP	ERRFIN
GORDY:	JMP	READY		;TYPE "READY".

CONT:	BNE	CONTRT		;MAKE SURE THERE IS A TERMINATOR.
	LDX	#ERRCN		;CONTINUE ERROR.
	LDY	OLDTXT+1	;A STORED TXTPTR OF ZERO IS SETUP
				;BY STKINI AND INDICATES THERE IS
				;NOTHING TO CONTINUE.
	;JEQ	ERROR		;"STOP", "END", TYPING CRLF TO 
				;"INPUT" AND  ^C SETUP OLDTXT.
	BNE	$+5
	JMP	ERROR
	;
	LDA	OLDTXT
	;STWD	TXTPTR
	STA	TXTPTR
	STY	TXTPTR+1
	;
	;LDWD	OLDLIN
	LDA	OLDLIN
	LDY	OLDLIN+1
	;
	;STWD	CURLIN
	STA	CURLIN
	STY	CURLIN+1
	;
CONTRT: RTS			;RETURN TO CALLER.

;;;NULL:	JSR	GETBYT
;;;	BNE	CONTRT		;MAKE SURE THERE IS TERMINATOR.
;;;	INX
;;;	CPX	#240		;IS THE NUMBER REASONABLE?
;;;	BCS	FCERR1		;"FUNCTION CALL" ERROR.
;;;	DEX			;BACK -1
;;;	STX	NULCNT
;;;	RTS
;;;FCERR1: JMP	FCERR

SAVE:	RTS			;FIXME

LOAD:	RTS			;FIXME

RUN:	;JEQ	RUNC		;IF NO LINE # ARGUMENT.
	BNE	$+5
	JMP	RUNC
	;
	JSR	CLEARC		;CLEAN UP -- RESET THE STACK.
	JMP	RUNC2		;MUST REPLACE RTS ADDR.
;
; A GOSUB ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
;
; LOW ADDRESS:
;	THE GOSUTK ONE BYTE
;	THE LINE NUMBER OF THE GOSUB STATEMENT TWO BYTES
;	A POINTER INTO THE TEXT OF THE GOSUB TWO BYTES
;
; HIGH ADDRESS.
;
; TOTAL FIVE BYTES.
;
GOSUB:	LDA	#3
	JSR	GETSTK		;MAKE SURE THERE IS ROOM.
	;PSHWD	TXTPTR		;PUSH ON THE TEXT POINTER.
	LDA	TXTPTR+1
	PHA
	LDA	TXTPTR
	PHA
	;
	;PSHWD	CURLIN		;PUSH ON THE CURRENT LINE NUMBER.
	LDA	CURLIN+1
	PHA
	LDA	CURLIN
	PHA
	;
	LDA	#GOSUTK
	PHA			;PUSH ON A GOSUB TOKEN.
RUNC2:	JSR	CHRGOT		;GET CHARACTER AND SET CODES FOR LINGET.
	JSR	GOTO		;USE RTS SCHEME TO "NEWSTT".
	JMP	NEWSTT

GOTO:	JSR	LINGET		;PICK UP THE LINE NUMBER IN "LINNUM".
	JSR	REMN		;SKIP TO END OF LINE.
	LDA	CURLIN+1
	CMP	LINNUM+1
	BCS	LUK4IT
	TYA
	SEC
	ADC	TXTPTR
	LDX	TXTPTR+1
	BCC	LUKALL
	INX
	BCS	LUKALL		;ALWAYS GOES.
LUK4IT: ;LDWX	TXTTAB
	LDA	TXTTAB
	LDX	TXTTAB+1
LUKALL: JSR	FNDLNC		;[X,A] ARE ALL SET UP.
QFOUND: BCC	USERR		;GOTO LINE IS NONEXISTANT.
	LDA	LOWTR
	SBC	#1
	STA	TXTPTR
	LDA	LOWTR+1
	SBC	#0
	STA	TXTPTR+1
GORTS:	RTS			;PROCESS THE STATEMENT.
;
; "RETURN" RESTORES THE LINE NUMBER AND TEXT PNTR FROM THE STACK
; AND ELIMINATES ALL THE "FOR" ENTRIES IN FRONT OF THE "GOSUB" ENTRY.
;
RETURN: BNE	GORTS		;NO TERMINATOR=BLOW HIM UP.
	LDA	#255
	STA	FORPNT+1	;MAKE SURE THE VARIABLE'S PNTR
				;NEVER GETS MATCHED.
	JSR	FNDFOR		;GO PAST ALL THE "FOR" ENTRIES.
	TXS
	CMP	#GOSUTK		;RETURN WITHOUT GOSUB?
	BEQ	RETU1
	LDX	#ERRRG
	BYTE	SKIP2
USERR:	LDX	#ERRUS		;NO MATCH SO "US" ERROR.
	JMP	ERROR		;YES.
SNERR2: JMP	SNERR
RETU1:	PLA			;REMOVE GOSUTK.
	;PULWD	CURLIN		;GET LINE NUMBER "GOSUB" WAS FROM.
	PLA
	STA	CURLIN
	PLA
	STA	CURLIN+1
	;
	;PULWD	TXTPTR		;GET TEXT PNTR FROM "GOSUB".
	PLA
	STA	TXTPTR
	PLA
	STA	TXTPTR+1
	;
DATA:	JSR	DATAN		;SKIP TO END OF STATEMENT, 
				;SINCE WHEN "GOSUB" STUCK THE TEXT  PNTR
				;ONTO THE STACK, THE LINE NUMBER ARG
				;HADN'T BEEN READ YET.
ADDON:	TYA
	CLC
	ADC	TXTPTR
	STA	TXTPTR
	BCC	REMRTS
	INC	TXTPTR+1
REMRTS: RTS			;"NEWSTT" RTS ADDR IS STILL THERE.

DATAN:	LDX	#":"		;"DATA" TERMINATES ON ":" AND NULL.
	BYTE	SKIP2
REMN:	LDX	#0		;THE ONLY TERMINATOR IS NULL.
	STX	CHARAC		;PRESERVE IT.
	LDY	#0		;THIS MAKES CHARAC=0 AFTER SWAP.
	STY	ENDCHR
EXCHQT: LDA	ENDCHR
	LDX	CHARAC
	STA	CHARAC
	STX	ENDCHR
REMER:	;LDADY	TXTPTR
	LDA	(TXTPTR),Y
	;
	BEQ	REMRTS		;NULL ALWAYS TERMINATES.
	CMP	ENDCHR		;IS IT THE OTHER TERMINATOR?
	BEQ	REMRTS		;YES, IT'S FINISHED.
	INY			;PROGRESS TO NEXT CHARACTER.
	CMP	#34		;IS IT A QUOTE?
	BNE	REMER		;NO, JUST CONTINUE.
	BEQ	EXCHQT		;YES, TIME TO TRADE.

IF:	JSR	FRMEVL		;EVALUATE A FORMULA.
	JSR	CHRGOT		;GET CURRENT CHARACTER.
	CMP	#GOTOTK		;IS TERMINATING CHARACTER A GOTOTK?
	BEQ	OKGOTO		;YES.
	;SYNCHK	THENTK		;NO, IT MUST BE "THEN".
	LDA	#THENTK
	JSR	SYNCHR
	;
OKGOTO: LDA	FACEXP		;0=FALSE. ALL OTHERS TRUE.
	BNE	DOCOND		;TRUE !
REM:	JSR	REMN		;SKIP REST OF STATEMENT.
	BEQ	ADDON		;WILL ALWAYS BRANCH.
DOCOND: JSR	CHRGOT		;TEST CURRENT CHARACTER.
	BCS	DOCO		;IF A NUMBER, GOTO IT.
	JMP	GOTO
DOCO:	JMP	GONE3		;INTERPRET NEW STATEMENT.

ONGOTO: JSR	GETBYT		;GET VALUE IN FACLO.
	PHA			;SAVE FOR LATER.
	CMP	#GOSUTK		;AN "ON ... GOSUB" PERHAPS?
	BEQ	ONGLOP		;YES.
SNERR3: CMP	#GOTOTK		;MUST BE "GOTOTK".
	BNE	SNERR2
ONGLOP: DEC	FACLO
	BNE	ONGLP1		;SKIP ANOTHER LINE NUMBER.
	PLA			;GET DISPATCH CHARACTER.
	JMP	GONE2
ONGLP1: JSR	CHRGET		;ADVANCE AND SET CODES.
	JSR	LINGET
	CMP	#44		;IS IT A COMMA?
	BEQ	ONGLOP
	PLA			;REMOVE STACK ENTRY (TOKEN).
ONGRTS: RTS			;EITHER END-OF-LINE OR SYNTAX ERROR.
;
; "LINGET" READS A LINE NUMBER FROM THE CURRENT TEXT POSITION.
;
; LINE NUMBERS RANGE FROM 0 TO 64000-1.
;
; THE ANSWER IS RETURNED IN "LINNUM".
; "TXTPTR" IS UPDATED TO POINT TO THE TERMINATING CHARCTER
; AND [A] = THE TERMINATING CHARACTER WITH CONDITION
; CODES SET UP TO REFLECT ITS VALUE.
;
LINGET: LDX	#0
	STX	LINNUM		;INITIALIZE LINE NUMBER TO ZERO.
	STX	LINNUM+1
MORLIN: BCS	ONGRTS		;IT IS NOT A DIGIT.
	SBC	#"0"-1		;-1 SINCE C=0.
	STA	CHARAC		;SAVE CHARACTER.
	LDA	LINNUM+1
	STA	INDEX
	CMP	#25		;LINE NUMBER WILL BE .LT. 64000?
	BCS	SNERR3
	LDA	LINNUM
	ASL	A		;MULTIPLY BY 10.
	ROL	INDEX
	ASL	A
	ROL	INDEX
	ADC	LINNUM
	STA	LINNUM
	LDA	INDEX
	ADC	LINNUM+1
	STA	LINNUM+1
	ASL	LINNUM
	ROL	LINNUM+1
	LDA	LINNUM
	ADC	CHARAC		;ADD IN DIGIT.
	STA	LINNUM
	BCC	NXTLGC
	INC	LINNUM+1
NXTLGC: JSR	CHRGET
	JMP	MORLIN

LET:	JSR	PTRGET		;GET PNTR TO VARIABLE INTO "VARPNT".
	;STWD	FORPNT		;PRESERVE POINTER.
	STA	FORPNT
	STY	FORPNT+1
	;
	;SYNCHK EQULTK		;"=" IS NECESSARY.
	LDA	#EQULTK
	JSR	SYNCHR
	;
	LDA	INTFLG		;SAVE FOR LATER.
	PHA
	LDA	VALTYP		;RETAIN THE VARIABLE'S VALUE TYPE.
	PHA
	JSR	FRMEVL		;GET VALUE OF FORMULA INTO "FAC".
	PLA
	ROL	A		;CARRY SET FOR STRING, OFF FOR
				;NUMERIC.
	JSR	CHKVAL		;MAKE SURE "VALTYP" MATCHES CARRY.
				;AND SET ZERO FLAG FOR NUMERIC.
	BNE	COPSTR		;IF NUMERIC, COPY IT.
COPNUM:
	PLA			;GET NUMBER TYPE.
QINTGR: BPL	COPFLT		;STORE A FLTING NUMBER.
	JSR	ROUND		;ROUND INTEGER.
	JSR	AYINT		;MAKE 2-BYTE NUMBER.
	LDY	#0
	LDA	FACMO		;GET HIGH.
	;STADY	FORPNT		;STORE IT.
	STA	(FORPNT),Y
	;
	INY
	LDA	FACLO		;GET LOW.
	;STADY	FORPNT
	STA	(FORPNT),Y
	;
	RTS
COPFLT: JMP	MOVVF		;PUT NUMBER @FORPNT.

COPSTR:
	PLA			;IF STRING, NO INTFLG.
INPCOM:

GETSPT:	LDY	#2		;GET PNTR TO DESCRIPTOR.
	;LDADY	FACMO
	LDA	(FACMO),Y
	;
	CMP	FRETOP+1	;SEE IF IT POINTS INTO STRING SPACE.
	BCC	DNTCPY		;IF [FRETOP],GT.[2&3,FACMO], DON'T COPY.
	BNE	QVARIA		;IT IS LESS.
	DEY
	;LDADY	FACMO
	LDA	(FACMO),Y
	;
	CMP	FRETOP		;COMPARE LOW ORDERS.
	BCC	DNTCPY
QVARIA: LDY	FACLO
	CPY	VARTAB+1	;IF [VARTAB].GT.[FACMO], DON'T COPY.
	BCC	DNTCPY
	BNE	COPY		;IT IS LESS.
	LDA	FACMO
	CMP	VARTAB		;COMPARE LOW ORDERS.
	BCS	COPY
DNTCPY: ;LDWD	FACMO
	LDA	FACMO
	LDY	FACMO+1
	;
	JMP	COPYZC
COPY:	LDY	#0
	;LDADY	FACMO
	LDA	(FACMO),Y
	;
	JSR	STRINI		;GET ROOM TO COPY STRING INTO.
	;LDWD	DSCPNT		;GET POINTER TO OLD DESCRIPTOR, SO
	LDA	DSCPNT
	LDY	DSCPNT+1
	;
	;STWD	STRNG1		;MOVINS CAN FIND STRING.
	STA	STRNG1
	STY	STRNG1+1
	;
	JSR	MOVINS		;COPY IT.
	;LDWDI	DSCTMP		;GET POINTER TO OLD DESCRIPTOR.
	LDA	#DSCTMP
	LDY	#DSCTMP>>8
	;
COPYZC: ;STWD	DSCPNT		;REMEMBER POINTER TO DESCRIPTOR.
	STA	DSCPNT
	STY	DSCPNT+1
	;
	JSR	FRETMS		;FREE UP THE TEMPORARY WITHOUT
				;FREEING UP ANY STRING SPACE.
	LDY	#0
	;LDADY	DSCPNT
	LDA	(DSCPNT),Y
	;
	;STADY	FORPNT
	STA	(FORPNT),Y
	;
	INY			;POINT TO STRING PNTR.
	;LDADY	DSCPNT
	LDA	(DSCPNT),Y
	;
	;STADY	FORPNT
	STA	(FORPNT),Y
	;
	INY
	;LDADY	DSCPNT
	LDA	(DSCPNT),Y
	;
	;STADY	FORPNT
	STA	(FORPNT),Y
	;
	RTS

STRDON: JSR	STRPRT
NEWCHR: JSR	CHRGOT		;REGET LAST CHARACTER.
PRINT:	BEQ	CRDO		;TERMINATOR SO TYPE CRLF.
PRINTC: BEQ	PRTRTS		;HERE AFTER SEEING TAB(X) OR , OR ;
				;IN WHICH CASE A TERMINATOR DOES NOT
				;MEAN TYPE A CRLF BUT JUST RTS.
	CMP	#TABTK		;TAB FUNCTION?
	BEQ	TABER		;YES.
	CMP	#SPCTK		;SPACE FUNCTION?
	CLC
	BEQ	TABER
	CMP	#44		;A COMMA?
	BEQ	COMPRT		;YES.
	CMP	#59		;A SEMICOLON?
	BEQ	NOTABR		;YES.
	JSR	FRMEVL		;EVALUATE THE FORMULA.
	BIT	VALTYP		;A STRING?
	BMI	STRDON		;YES.
	JSR	FOUT
	JSR	STRLIT		;BUILD DESCRIPTOR.
LINCHK: JSR	STRPRT		;PRINT THE NUMBER.
	JSR	OUTSPC		;PRINT A SPACE
	BNE	NEWCHR		;ALWAYS GOES.
CRDO:
	LDA	#13		;MAKE TRMPOS LESS THAN LINE LENGTH.
	STA	TRMPOS
	JSR	OUTDO
	LDA	#10
	JSR	OUTDO
CRFIN:
	EOR	#255
PRTRTS: RTS

COMPRT: LDA	TRMPOS
NCMPOS	EQU	((LINLEN/CLMWID)-1)*CLMWID	;CLMWID BEYOND WHICH THERE ARE
				;NO MORE COMMA FIELDS.
	CMP	NCMWID		;SO ALL COMMA DOES IS "CRDO".

	BCC	MORCOM
	JSR	CRDO		;TYPE CRLF.
	JMP	NOTABR		;AND QUIT IF BEYOND LAST FIELD.
MORCOM: SEC
MORCO1: SBC	#CLMWID		;GET [A] MODULUS CLMWID.
	BCS	MORCO1
	EOR	#255		;FILL PRINT POS OUT TO EVEN CLMWID SO
	ADC	#1
	BNE	ASPAC		;PRINT [A] SPACES.

TABER:	PHP			;REMEMBER IF SPC OR TAB FUNCTION.
	JSR	GTBYTC		;GET VALUE INTO ACCX.
	CMP	#41
	BNE	SNERR4
	PLP
	BCC	XSPAC		;PRINT [X] SPACES.
	TXA
	SBC	TRMPOS
	BCC	NOTABR		;NEGATIVE, DON'T PRINT ANY.
ASPAC:	TAX
XSPAC:	INX
XSPAC2: DEX			;DECREMENT THE COUNT.
	BNE	XSPAC1
NOTABR: JSR	CHRGET		;REGET LAST CHARACTER.
	JMP	PRINTC		;DON'T CALL CRDO.
XSPAC1: JSR	OUTSPC
	BNE	XSPAC2
;
; PRINT THE STRING POINTED TO BY [Y,A] WHICH ENDS WITH A ZERO.
; IF THE STRING IS BELOW DSCTMP IT WILL BE COPIED INTO STRING SPACE.
;
STROUT: JSR	STRLIT		;GET A STRING LITERAL.
;
; PRINT THE STRING WHOSE DESCRIPTOR IS POINTED TO BY FACMO.
;
STRPRT: JSR	FREFAC		;RETURN TEMP POINTER.
	TAX			;PUT COUNT INTO COUNTER.
	LDY	#0
	INX			;MOVE ONE AHEAD.
STRPR2: DEX
	BEQ	PRTRTS		;ALL DONE.
	;LDADY	INDEX		;PNTR TO ACT STRNG SET BY FREFAC.
	LDA	(INDEX),Y
	;
	JSR	OUTDO
	INY
	CMP	#13
	BNE	STRPR2
	JSR	CRFIN		;TYPE REST OF CARRIAGE RETURN.
	JMP	STRPR2		;AND ON AND ON.
;
; OUTDO OUTPUTS THE CHARACTER IN ACCA, USING CNTWFL
; (SUPPRESS OR NOT), TRMPOS (PRINT HEAD POSITION),
; TIMING, ETCQ. NO REGISTERS ARE CHANGED.
;
OUTSPC:
	LDA	#" "
	BYTE	SKIP2
OUTQST: LDA	#"?"
OUTDO:
	BIT	CNTWFL		;SHOULDN'T AFFECT CHANNEL I/O!
	BMI	OUTRTS
	PHA
	CMP	#32		;IS THIS A PRINTING CHAR?
	BCC	TRYOUT		;NO, DON'T INCLUDE IT IN TRMPOS.
	LDA	TRMPOS
	CMP	LINWID		;LENGTH = TERMINAL WIDTH?
	BNE	OUTDO1
	JSR	CRDO		;YES, TYPE CRLF
OUTDO1:
INCTRM: INC	TRMPOS		;INCREMENT COUNT.
TRYOUT: PLA			;RESTORE THE A REGISTER

OUTLOC: JSR	OUTCH		;OUTPUT THE CHARACTER.
OUTRTS: AND	#255		;SET Z=0.
GETRTS: RTS
;
; HERE WHEN THE DATA THAT WAS TYPED IN OR IN "DATA" STATEMENTS
; IS IMPROPERLY FORMATTED. FOR "INPUT" WE START AGAIN.
; FOR "READ" WE GIVE A SYNTAX ERROR AT THE DATA LINE.
;
TRMNOK: LDA	INPFLG
	BEQ	TRMNO1		;IF INPUT TRY AGAIN.
	BMI	GETDTL
	LDY	#255		;MAKE IT LOOK DIRECT.
	BNE	STCURL		;ALWAYS GOES.
GETDTL:
	;LDWD	DATLIN		;GET DATA LINE NUMBER.
	LDA	DATLIN
	LDY	DATLIN+1
	;
STCURL: ;STWD	CURLIN		;MAKE IT CURRENT LINE.
	STA	CURLIN
	STY	CURLIN+1
	;
SNERR4: JMP	SNERR
TRMNO1:
DOAGIN:	;LDWDI	TRYAGN
	LDA	#TRYAGN
	LDY	#TRYAGN>>8
	JSR	STROUT		;PRINT "?REDO FROM START".
	;LDWD	OLDTXT		;POINT AT START
	LDA	OLDTXT
	LDY	OLDTXT+1
	;STWD	TXTPTR		;OF THIS CURRENT LINE.
	STA	TXTPTR
	STY	TXTPTR+1
	RTS			;GO TO "NEWSTT".
GET:	JSR	ERRDIR		;DIRECT IS NOT OK.
GETTTY: ;LDXYI	BUF+1		;POINT TO 0.
	LDX	#BUF+1
	LDY	#(BUF+1)>>8
	LDA	#0		;TO STUFF AND TO POINT.
	STA	BUF+1
	LDA	#64		;TURN ON V-BIT.
	JSR	INPCO1		;DO THE GET.
	RTS

INPUT:
	LSR	CNTWFL		;BE TALKATIVE.
	CMP	#34		;A QUOTE?
	BNE	NOTQTI		;NO MESSAGE.
	JSR	STRTXT		;LITERALIZE THE STRING IN TEXT
	;SYNCHK	59		;MUST END WITH SEMICOLON.
	LDA	#59
	JSR	SYNCHR
	;
	JSR	STRPRT		;PRINT IT OUT.
NOTQTI: JSR	ERRDIR		;USE COMMON ROUTINE SINCE DEF DIRECT
	LDA	#44		;GET COMMA.
	STA	BUF-1
				;IS ALSO ILLEGAL.
GETAGN: JSR	QINLIN		;TYPE "?" AND INPUT A LINE OF TEXT.
	LDA	BUF		;ANYTHING INPUT?
	BNE	INPCON		;YES, CONTINUE.
	CLC			;MAKE SURE DONT PRINT BREAK
	JMP	STPEND		;NO, STOP.
QINLIN:
	JSR	OUTQST
	JSR	OUTSPC
GINLIN: JMP	INLIN
READ:	;LDXY	DATPTR		;GET LAST DATA LOCATION.
	LDX	DATPTR
	LDY	DATPTR+1
	BYTE	$A9		;LDAI TYA TO MAKE IT NONZERO.
	TYA
	BYTE	SKIP2
INPCON: LDA	#0		;SET FLAG THAT THIS IS INPUT
INPCO1: STA	INPFLG		;STORE THE FLAG.
;
; IN THE PROCESSING OF DATA AND READ STATEMENTS:
; ONE POINTER POINTS TO THE DATA (IE, THE NUMBERS BEING FETCHED)
; AND ANOTHER POINTS TO THE LIST OF VARIABLES.
;
; THE POINTER INTO THE DATA ALWAYS STARTS POINTING TO A
; TERMINATOR -- A , : OR END-OF-LINE.
;
; AT THIS POINT TXTPTR POINTS TO LIST OF VARIABLES AND
; [Y,X] POINTS TO DATA OR INPUT LINE.
;
	;STXY	INPPTR
	STX	INPPTR
	STY	INPPTR+1
INLOOP: JSR	PTRGET		;READ VARIABLE LIST.
	;STWD	FORPNT		;SAVE POINTER FOR "LET" STRING STUFFING.
				;RETURNS PNTR TOP VAR IN VARPNT.
	STA	FORPNT
	STY	FORPNT+1
	;LDWD	TXTPTR		;SAVE TEXT PNTR.
	LDA	TXTPTR
	LDY	TXTPTR+1
	;
	;STWD	VARTXT
	STA	VARTXT
	STY	VARTXT+1
	;
	;LDXY	INPPTR
	LDX	INPPTR
	LDY	INPPTR+1
	;
	;STXY	TXTPTR
	STX	TXTPTR
	STY	TXTPTR+1
	;
	JSR	CHRGOT		;GET IT AND SET Z IF TERM.
	BNE	DATBK1
	BIT	INPFLG

;;;	BVC	QDATA
;;;	JSR	CZGETL		;DON'T WANT INCHR. JUST ONE.
;;;	STA	BUF		;MAKE IT FIRST CHARACTER.
;;;	;LDXYI	<BUF-1>		;POINT JUST BEFORE IT.
;;;	LDX	#BUF-1
;;;	LDY	#(BUF-1)>>8
;;;	;
;;;	BNE	DATBK		;GO PROCESS.

QDATA:	BMI	DATLOP		;SEARCH FOR ANOTHER DATA STATEMENT.
	JSR	OUTQST
GETNTH: JSR	QINLIN		;GET ANOTHER LINE.
DATBK:	;STXY	TXTPTR		;SET FOR "CHRGET".
	STX	TXTPTR
	STY	TXTPTR+1
DATBK1: JSR	CHRGET
	BIT	VALTYP		;GET VALUE TYPE.
	BPL	NUMINS		;INPUT A NUMBER IF NUMERIC.
	BIT	INPFLG		;GET?
	BVC	SETQUT		;NO, GO SET QUOTE.
	INX
	STX	TXTPTR
	LDA	#0		;ZERO TERMINATORS.
	STA	CHARAC
	BEQ	RESETC
SETQUT: STA	CHARAC		;ASSUME QUOTED STRING.
	CMP	#34		;TERMINATORS OK?
	BEQ	NOWGET		;YES.
	LDA	#":"		;SET TERMINATORS TO ":" AND
	STA	CHARAC
	LDA	#44		;COMMA.
RESETC: CLC
NOWGET: STA	ENDCHR
	;LDWD	TXTPTR
	LDA	TXTPTR
	LDY	TXTPTR+1
	ADC	#0		;C IS SET PROPERLY ABOVE.
	BCC	NOWGE1
	INY
NOWGE1: JSR	STRLT2		;MAKE A STRING DESCRIPTOR FOR THE VALUE
				;AND COPY IF NECESSARY.
	JSR	ST2TXT		;SET TEXT POINTER.
	JSR	INPCOM		;DO ASSIGNMENT.
	JMP	STRDN2
NUMINS: JSR	FIN
	LDA	INTFLG		;SET CODES ON FLAG.
	JSR	QINTGR		;GO DECIDE ON FLOAT.
STRDN2: JSR	CHRGOT		;READ LAST CHARACTER.
	BEQ	TRMOK		;":" OR EOL IS OK.
	CMP	#44		;A COMMA?
	;JNE	TRMNOK
	BEQ	$+5
	JMP	TRMNOK
	;
TRMOK:	;LDWD	TXTPTR
	LDA	TXTPTR
	LDY	TXTPTR+1
	;STWD	INPPTR		;SAVE FOR MORE READS.
	STA	INPPTR
	STY	INPPTR+1
	;LDWD	VARTXT
	LDA	VARTXT
	LDY	VARTXT+1
	;STWD	TXTPTR		;POINT TO VARIABLE LIST.
	STA	TXTPTR
	STY	TXTPTR+1
	JSR	CHRGOT		;LOOK AT LAST VARIABLE LIST CHARACTER.
	BEQ	VAREND		;THAT'S THE END OF THE LIST.
	JSR	CHKCOM		;NOT END. CHECK FOR COMMA.
	JMP	INLOOP
;
; SUBROUTINE TO FIND DATA
; THE SEARCH IS MADE BY USING THE EXECUTION CODE FOR DATA TO
; SKIP OVER STATEMENTS. THE START WORD OF EACH STATEMENT
; IS COMPARED WITH "DATATK". EACH NEW LINE NUMBER
; IS STORED IN "DATLIN" SO THAT IF AN ERROR OCCURS
; WHILE READING DATA THE ERROR MESSAGE CAN GIVE THE LINE
; NUMBER OF THE ILL-FORMATTED DATA.
;
DATLOP: JSR	DATAN		;SKIP SOME TEXT.
	INY
	TAX			;END OF LINE?
	BNE	NOWLIN		;SHO AIN'T.
	LDX	#ERROD		;YES = "NO DATA" ERROR.
	INY
	;LDADY	TXTPTR
	LDA	(TXTPTR),Y
	;
	BEQ	ERRGO5
	INY
	;LDADY	TXTPTR		;GET HIGH BYTE OF LINE NUMBER.
	LDA	(TXTPTR),Y
	;
	STA	DATLIN
	INY
	;LDADY	TXTPTR		;GET LOW BYTE.
	LDA	(TXTPTR),Y
	;
	INY
	STA	DATLIN+1
NOWLIN: ;LDADY	TXTPTR		;HOW IS IT?
	LDA	(TXTPTR),Y
	;
	TAX
	JSR	ADDON		;ADD [Y] TO [TXTPTR].
	CPX	#DATATK		;IS IT A "DATA" STATEMENT.
	BNE	DATLOP		;NOT QUITE RIGHT. KEEP LOOKING.
	JMP	DATBK1		;THIS IS THE ONE !
VAREND: ;LDWD	INPPTR		;PUT AWAY A NEW DATA PNTR MAYBE.
	LDA	INPPTR
	LDY	INPPTR+1
	LDX	INPFLG
	BPL	VARY0
	JMP	RESFIN
VARY0:	LDY	#0
	;LDADY	INPPTR		;LAST DATA CHR COULD HAVE BEEN
	LDA	(INPPTR),Y
	;
				;COMMA OR COLON BUT SHOULD BE NULL.
	BEQ	INPRTS		;IT IS NULL.
	;LDWDI	EXIGNT
	LDA	#EXIGNT
	LDY	#EXIGNT>>8
	JMP	STROUT		;TYPE "?EXTRA IGNORED"
INPRTS: RTS			;DO NEXT STATEMENT.
EXIGNT: BYTE	"?EXTRA IGNORED"
	BYTE	13,10
	BYTE	0
TRYAGN: BYTE	"?REDO FROM START"
	BYTE	13,10
	BYTE	0
;
; A "FOR" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
;
; LOW ADDRESS
;	TOKEN (FORTK) 1 BYTE
;	A POINTER TO THE LOOP VARIABLE 2 BYTES
;	THE STEP 4+ADDPRC BYTES
;	A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
;	THE UPPER VALUE (PACKED) 4+ADDPRC BYTES
;	THE LINE NUMBER OF THE "FOR" STATEMENT 2 BYTES
;	A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
; HIGH ADDRESS
;
; TOTAL 16+2*ADDPRC BYTES.
;
NEXT:	BNE	GETFOR
	LDY	#0		;WITHOUT ARG CALL "FNDFOR" WITH
	BEQ	STXFOR		;[FORPNT]=0.
GETFOR: JSR	PTRGET		;GET A POINTER TO LOOP VARIABLE
STXFOR: ;STWD	FORPNT		;INTO "FORPNT".
	STA	FORPNT
	STY	FORPNT+1
	JSR	FNDFOR		;FIND THE MATCHING ENTRY IF ANY.
	BEQ	HAVFOR
	LDX	#ERRNF		;"NEXT WITHOUT FOR".
ERRGO5: BEQ	ERRGO4
HAVFOR: TXS			;SETUP STACK. CHOP FIRST.
	TXA
	CLC
	ADC	#4		;POINT TO INCREMENT
	PHA			;SAVE THIS POINTER TO RESTORE TO [A]
	ADC	#5+ADDPRC	;POINT TO UPPER LIMIT
	STA	INDEX2		;SAVE AS INDEX
	PLA			;RESTORE POINTER TO INCREMENT
	LDY	#1		;SET HI ADDR OF THING TO MOVE.
	JSR	MOVFM		;GET QUANTITY INTO THE FAC.
	TSX
	LDA	257+7+ADDPRC,X	;SET SIGN CORRECTLY.
	STA	FACSGN
	;LDWD	FORPNT
	LDA	FORPNT
	LDY	FORPNT+1
	;
	JSR	FADD		;ADD INC TO LOOP VARIABLE.
	JSR	MOVVF		;PACK THE FAC INTO MEMORY.
	LDY	#1
	JSR	FCOMPN		;COMPARE FAC WITH UPPER VALUE.
	TSX
	SEC
	SBC	257+7+ADDPRC,X	;SUBTRACT SIGN OF INC FROM SIGN OF
				;OF (CURRENT VALUE-FINAL VALUE).
	BEQ	LOOPDN		;IF SIGN (FINAL-CURRENT)-SIGN STEP=0
				;THEN LOOP IS DONE.
	LDA	2*ADDPRC+12+257,X
	STA	CURLIN		;STORE LINE NUMBER OF "FOR" STATEMENT.
	LDA	257+13+(2*ADDPRC),X
	STA	CURLIN+1
	LDA	2*ADDPRC+15+257,X
	STA	TXTPTR		;STORE TEXT PNTR INTO "FOR" STATEMENT.
	LDA	2*ADDPRC+14+257,X
	STA	TXTPTR+1
NEWSGO: JMP	NEWSTT		;PROCESS NEXT STATEMENT.
LOOPDN: TXA
	ADC	#2*ADDPRC+15		;ADDS 16 WITH CARRY.
	TAX
	TXS			;NEW STACK PNTR.
	JSR	CHRGOT
	CMP	#44		;COMMA AT END?
	BNE	NEWSGO
	JSR	CHRGET
	JSR	GETFOR		;DO NEXT BUT DON'T ALLOW BLANK VARIABLE
				;PNTR. [VARPNT] IS THE STK PNTR WHICH
				;NEVER MATCHES ANY POINTER.
				;JSR TO PUT ON DUMMY NEWSTT ADDR.
;
; THESE ROUTINES CHECK FOR CERTAIN "VALTYP".
; [C] IS NOT PRESERVED.
;
FRMNUM: JSR	FRMEVL
CHKNUM: CLC
	BYTE	SKIP1
CHKSTR: SEC			;SET CARRY.
CHKVAL: BIT	VALTYP		;WILL NOT F UP "VALTYP".
	BMI	DOCSTR
	BCS	CHKERR
CHKOK:	RTS
DOCSTR: BCS	CHKOK
CHKERR: LDX	#ERRTM
ERRGO4: JMP	ERROR
;
; THE FORMULA EVALUATOR STARTS WITH
; [TXTPTR] POINTING TO THE FIRST CHARACTER OF THE FORMULA.
; AT THE END [TXTPTR] POINTS TO THE TERMINATOR.
; THE RESULT IS LEFT IN THE FAC.
; ON RETURN [A] DOES NOT REFLECT THE TERMINATOR.
;
; THE FORMULA EVALUATOR USES THE OPERATOR LIST (OPTAB)
; TO DETERMINE PRECEDENCE AND DISPATCH ADDRESSES FOR 
; EACH OPERATOR.
; A TEMPORARY RESULT ON THE STACK HAS THE FOLLOWING FORMAT.
;	THE ADDRESS OF THE OPERATOR ROUTINE.
;	THE FLOATING POINT TEMPORARY RESULT.
;	THE PRECEDENCE OF THE OPERATOR.
;
FRMEVL: LDX	TXTPTR
	BNE	FRMEV1
	DEC	TXTPTR+1
FRMEV1: DEC	TXTPTR
	LDX	#0		;INITIAL DUMMY PRECEDENCE IS 0.
	BYTE	SKIP1
LPOPER: PHA			;SAVE LOW PRECEDENCE. (MASK.)
	TXA
	PHA			;SAVE HIGH PRECEDENCE.
	LDA	#1
	JSR	GETSTK		;MAKE SURE THERE IS ROOM FOR
				;RECURSIVE CALLS.
	JSR	EVAL		;EVALUATE SOMETHING.
	;CLR	OPMASK		;PREPARE TO BUILD MASK MAYBE.
	LDA	#0
	STA	OPMASK
TSTOP:	JSR	CHRGOT		;REGET LAST CHARACTER.
LOPREL: SEC			;PREP TO SUBTRACT.
	SBC	#GREATK		;IS CURRENT CHARACTER A RELATION?
	BCC	ENDREL		;NO. RELATIONS ALL THROUGH.
	CMP	#LESSTK-GREATK+1 ;REALLY RELATIONAL?
	BCS	ENDREL		;NO -- JUST BIG.
	CMP	#1		;RESET CARRY FOR ZERO ONLY.
	ROL	A		;0 TO 1, 1 TO 2, 2 TO 4.
	EOR	#1
	EOR	OPMASK		;BRING IN THE OLD BITS.
	CMP	OPMASK		;MAKE SURE THE NEW MASK IS BIGGER.
	BCC	SNERR5		;SYNTAX ERROR. BECAUSE TWO OF THE SAME.
	STA	OPMASK		;SAVE MASK.
	JSR	CHRGET
	JMP	LOPREL		;GET THE NEXT CANDIDATE.
ENDREL: LDX	OPMASK		;WERE THERE ANY?
	BNE	FINREL		;YES, HANDLE AS SPECIAL OP.
	BCS	QOP		;NOT AN OPERATOR.
	ADC	#GREATK-PLUSTK
	BCC	QOP		;NOT AN OPERATOR.
	ADC	VALTYP		;[C]=1.
	;JEQ	CAT		;ONLY IF [A]=0 AND [VALTYP]=-1 (A STR).
	BNE	$+5
	JMP	CAT
	;
	ADC	#255		;GET BACK ORIGINAL [A].
	STA	INDEX1
	ASL	A		;MULTIPLY BY 2.
	ADC	INDEX1		;BY THREE.
	TAY			;SET UP FOR LATER.
QPREC:	PLA			;GET PREVIOUS PRECEDENCE.
	CMP	OPTAB,Y		;IS OLD PRECEDENCE GREATER OR EQUAL?
	BCS	QCHNUM		;YES, GO OPERATE.
	JSR	CHKNUM		;CAN'T BE STRING HERE.
DOPREC: PHA			;SAVE OLD PRECEDENCE.
NEGPRC: JSR	DOPRE1		;SET A RETURN ADDRESS FOR OP.
	PLA			;PULL OFF PREVIOUS PRECEDENCE.
	LDY	OPPTR		;GET POINTER TO OP.
	BPL	QPREC1		;THAT'S A REAL OPERATOR.
	TAX			;DONE ?
	BEQ	QOPGO		;DONE !
	BNE	PULSTK
FINREL: LSR	VALTYP		;GET VALUE TYPE INTO "C".
	TXA
	ROL	A		;PUT VALTYP INTO LOW ORDER BIT OF MASK.
	LDX	TXTPTR		;DECREMENT TEXT POINTER.
	BNE	FINRE2
	DEC	TXTPTR+1
FINRE2: DEC	TXTPTR
	LDY	#PTDORL-OPTAB	;MAKE [YREG] POINT AT OPERATOR ENTRY.
	STA	OPMASK		;SAVE THE OPERATION MASK.
	BNE	QPREC		;SAVE IT ALL. BR ALWAYS.
				;NOTE B7(VALTYP)=0 SO CHKNUM CALL IS OK.
QPREC1: CMP	OPTAB,Y		;LAST PRECEDENCE IS GREATER?
	BCS	PULSTK		;YES, GO OPERATE.
	BCC	DOPREC		;NO SAVE ARGUMENT AND GET OTHER OPERAND.
DOPRE1: LDA	OPTAB+2,Y
	PHA			;DISP ADDR GOES ONTO STACK.
	LDA	OPTAB+1,Y
	PHA
	JSR	PUSHF1		;SAVE FAC ON STACK UNPACKED.
	LDA	OPMASK		;[ACCA] MAY BE MASK FOR REL.
	JMP	LPOPER
SNERR5: JMP	SNERR		;GO TO AN ERROR.
PUSHF1: LDA	FACSGN
	LDX	OPTAB,Y		;GET HIGH PRECEDENCE.
PUSHF:	TAY			;GET POINTER INTO STACK.
	PLA
	STA	INDEX1
	INC	INDEX1
	PLA
	STA	INDEX1+1
	TYA
				;STORE FAC ON STACK UNPACKED.
	PHA			;START WITH SIGN SET UP.
FORPSH: JSR	ROUND		;PUT ROUNDED FAC ON STACK.
	LDA	FACLO		;ENTRY POINT TO SKIP STORING SIGN.
	PHA
	LDA	FACMO
	PHA
	LDA	FACMOH
	PHA
	LDA	FACHO
	PHA
	LDA	FACEXP
	PHA
	;JMPD	INDEX1		;RETURN.
	JMP	(INDEX1)
	;
QOP:	LDY	#255
	PLA			;GET HIGH PRECEDENCE OF LAST OP.
QOPGO:	BEQ	QOPRTS		;DONE !
QCHNUM: CMP	#100		;RELATIONAL OPERATOR?
	BEQ	UNPSTK		;YES, DON'T CHECK OPERAND.
	JSR	CHKNUM		;MUST BE NUMBER.
UNPSTK: STY	OPPTR		;SAVE OPERATOR'S POINTER FOR NEXT TIME.
PULSTK: PLA			;GET MASK FOR REL OP IF IT IS ONE.
	LSR	A		;SETUP [C] FOR DOREL'S "CHKVAL".
	STA	DOMASK		;SAVE FOR "DOCMP".
	PLA			;UNPACK STACK INTO ARG.
	STA	ARGEXP
	PLA
	STA	ARGHO
	PLA
	STA	ARGMOH
	PLA
	STA	ARGMO
	PLA
	STA	ARGLO
	PLA
	STA	ARGSGN
	EOR	FACSGN		;GET PROBABLE RESULT SIGN.
	STA	ARISGN		;ARITHMETIC SIGN. USED BY
				;ADD, SUB, MULT, DIV.
QOPRTS: LDA	FACEXP		;GET IT AND SET CODES.
UNPRTS: RTS			;RETURN.

EVAL:	;CLR	VALTYP		;ASSUME VALUE WILL BE NUMERIC.
	LDA	#0
	STA	VALTYP
EVAL0:	JSR	CHRGET		;GET A CHARACTER.
	BCS	EVAL2
EVAL1:	JMP	FIN		;IT IS A NUMBER.
EVAL2:	JSR	ISLETC		;VARIABLE NAME?
	BCS	ISVAR		;YES.
QDOT:	CMP	#"."		;LEADING CHARACTER OF CONSTANT?
	BEQ	EVAL1
	CMP	#MINUTK		;NEGATION?
	BEQ	DOMIN		;SHO IS.
	CMP	#PLUSTK
	BEQ	EVAL0
	CMP	#34		;A QUOTE? A STRING?
	BNE	EVAL3
STRTXT: ;LDWD	TXTPTR
	LDA	TXTPTR
	LDY	TXTPTR+1
	;
	ADC	#0		;TO INC, ADD C=1.
	BCC	STRTX2
	INY
STRTX2: JSR	STRLIT		;YES. GO PROCESS IT.
	JMP	ST2TXT
EVAL3:	CMP	#NOTTK		;CHECK FOR "NOT" OPERATOR.
	BNE	EVAL4
	LDY	#NOTTAB-OPTAB		;"NOT" HAS PRECEDENCE 90.
	BNE	GONPRC		;GO DO ITS EVALUATION.
NOTOP:	JSR	AYINT		;INTEGERIZE.
	LDA	FACLO		;GET THE ARGUMENT.
	EOR	#255
	TAY
	LDA	FACMO
	EOR	#255
	JMP	GIVAYF		;FLOAT [Y,A] AS RESULT IN FAC.
				;AND RETURN.
EVAL4:	CMP	#FNTK		;USER-DEFINED FUNCTION?
	;JEQ	FNDOER
	BNE	$+5
	JMP	FNDOER
	;
	CMP	#ONEFUN		;A FUNCTION NAME?
	BCC	PARCHK		;FUNCTIONS ARE THE HIGHEST NUMBERED
	JMP	ISFUN		;CHARACTERS SO NO NEED TO CHECK
				;AN UPPER-BOUND.
PARCHK: JSR	CHKOPN		;ONLY POSSIBILITY LEFT IS
	JSR	FRMEVL		;A FORMULA IN PARENTHESIS.
				;RECURSIVELY EVALUATE THE FORMULA.
CHKCLS: LDA	#41		;CHECK FOR A RIGHT PARENTHESE
	BYTE	SKIP2
CHKOPN: LDA	#40
	BYTE	SKIP2
CHKCOM: LDA	#44
;
; "SYNCHK" LOOKS AT THE CURRENT CHARACTER TO MAKE SURE IT
; IS THE SPECIFIC THING LOADED INTO ACCA JUST BEFORE THE CALL TO
; "SYNCHK". IF NOT, IT CALLS THE "SYNTAX ERROR" ROUTINE.
; OTHERWISE IT GOBBLES THE NEXT CHAR AND RETURNS,
;
; [A]=NEW CHAR AND TXTPTR IS ADVANCED BY "CHRGET".
;
SYNCHR: LDY	#0
	;CMPDY	TXTPTR		;CHARACTERS EQUAL?
	CMP	(TXTPTR),Y
	;
	BNE	SNERR
CHRGO5: JMP	CHRGET
SNERR:	LDX	#ERRSN		;"SYNTAX ERROR"
	JMP	ERROR
DOMIN:	LDY	#NEGTAB-OPTAB	;A PRECEDENCE BELOW "^".
GONPRC: PLA			;GET RID OF RTS ADDR.
	PLA
	JMP	NEGPRC		;EVALUTE FOR NEGATION.

ISVAR:	JSR	PTRGET		;GET A PNTR TO VARIABLE.
ISVRET: ;STWD	FACMO
	STA	FACMO
	STY	FACMO+1
	LDX	VALTYP
	BEQ	GOOO		;THE STRING IS SET UP.
	LDX	#0
	STX	FACOV
STRRTS: RTS
GOOO:
	LDX	INTFLG
	BPL	GOOOOO
	LDY	#0
	;LDADY	FACMO		;FETCH HIGH.
	LDA	(FACMO),Y
	;
	TAX
	INY
	;LDADY	FACMO
	LDA	(FACMO),Y
	;
	TAY			;PUT LOW IN Y.
	TXA			;GET HIGH IN A.
	JMP	GIVAYF		;FLOAT AND RETURN.
GOOOOO:
QSTATV:
	JMP	MOVFM		;MOVE ACTUAL VALUE IN.
				;AND RETURN.

ISFUN:	ASL	A		;MULTIPLY BY TWO.
	PHA
	TAX
	JSR	CHRGET		;SET UP FOR SYNCHK.
	CPX	#2*LASNUM-256+1	;IS IT PAST "LASNUM"?
	BCC	OKNORM		;NO, MUST BE NORMAL FUNCTION.
;
; MOST FUNCTIONS TAKE A SINGLE ARGUMENT.
; THE RETURN ADDRESS OF THESE FUNCTIONS IS "CHKNUM"
; WHICH ASCERTAINS THAT [VALTYP]=0  (NUMERIC).
; NORMAL FUNCTIONS THAT RETURN STRING RESULTS
; (E.G., CHR$) MUST POP OFF THAT RETURN ADDR AND
; RETURN DIRECTLY TO "FRMEVL".
;
; THE SO-CALLED "FUNNY" FUNCTIONS CAN TAKE MORE THAN ONE ARGUMENT,
; THE FIRST OF WHICH MUST BE STRING AND THE SECOND OF WHICH
; MUST BE A NUMBER BETWEEN 0 AND 255.
; THE CLOSED PARENTHESIS MUST BE CHECKED AND RETURN IS DIRECTLY
; TO "FRMEVL" WITH THE TEXT PNTR POINTING BEYOND THE ")".
; THE POINTER TO THE DESCRIPTOR OF THE STRING ARGUMENT
; IS STORED ON THE STACK UNDERNEATH THE VALUE OF THE
; INTEGER ARGUMENT.
;
	JSR	CHKOPN		;CHECK FOR AN OPEN PARENTHESE
	JSR	FRMEVL		;EAT OPEN PAREN AND FIRST ARG.
	JSR	CHKCOM		;TWO ARGS SO COMMA MUST DELIMIT.
	JSR	CHKSTR		;MAKE SURE FIRST WAS STRING.
	PLA			;GET FUNCTION NUMBER.
	TAX
	;PSHWD	FACMO		;SAVE POINTER AT STRING DESCRIPTOR
	LDA	FACMO+1
	PHA
	LDA	FACMO
	PHA
	;
	TXA
	PHA			;RESAVE FUNCTION NUMBER.
				;THIS MUST BE ON STACK SINCE RECURSIVE.
	JSR	GETBYT		;[X]=VALUE OF FORMULA.
	PLA			;GET FUNCTION NUMBER.
	TAY
	TXA
	PHA
	JMP	FINGO		;DISPATCH TO FUNCTION.
OKNORM: JSR	PARCHK		;READ A FORMULA SURROUNDED BY PARENS.
	PLA			;GET DISPATCH FUNCTION.
	TAY
FINGO:	LDA	FUNDSP-2*ONEFUN+256,Y	;MODIFY DISPATCH ADDRESS.
	STA	JMPER+1
	LDA	FUNDSP-2*ONEFUN+257,Y
	STA	JMPER+2
	JSR	JMPER		;DISPATCH!
				;STRING FUNCTIONS REMOVE THIS RET ADDR.
	JMP	CHKNUM		;CHECK IT FOR NUMERICNESS AND RETURN.

OROP:	LDY	#255		;MUST ALWAYS COMPLEMENT..
	BYTE	SKIP2
ANDOP:	LDY	#0
	STY	COUNT		;OPERATOR.
	JSR	AYINT		;[FACMO&LO]=INT VALUE AND CHECK SIZE.
	LDA	FACMO		;USE DEMORGAN'S LAW ON HIGH
	EOR	COUNT
	STA	INTEGR
	LDA	FACLO		;AND LOW.
	EOR	COUNT
	STA	INTEGR+1
	JSR	MOVFA
	JSR	AYINT		;[FACMO&LO]=INT OF ARG.
	LDA	FACLO
	EOR	COUNT
	AND	INTEGR+1
	EOR	COUNT		;FINISH OUT DEMORGAN.
	TAY			;SAVE HIGH.
	LDA	FACMO
	EOR	COUNT
	AND	INTEGR
	EOR	COUNT
	JMP	GIVAYF		;FLOAT [A.Y] AND RET TO USER.
;
; TIME TO PERFORM A RELATIONAL OPERATOR.
; [DOMASK] CONTAINS THE BITS AS TO WHICH RELATIONAL
; OPERATOR IT WAS. CARRY BIT ON=STRING COMPARE.
;
DOREL:	JSR	CHKVAL		;CHECK FOR MATCH.
	BCS	STRCMP		;IT IS A STRING.
	LDA	ARGSGN		;PACK ARG FOR FCOMP.
	ORA	#127
	AND	ARGHO
	STA	ARGHO
	;LDWDI	ARGEXP
	LDA	#ARGEXP
	LDY	#ARGEXP>>8
	JSR	FCOMP
	TAX
	JMP	QCOMP
STRCMP: ;CLR	VALTYP		;RESULT WILL BE NUMERIC.
	LDA	#0
	STA	VALTYP
	DEC	OPMASK		;TURN OFF VALTYP WHICH WAS STRING.
	JSR	FREFAC		;FREE THE FACLO STRING.
	STA	DSCTMP		;SAVE FOR LATER.
	;STXY	DSCTMP+1
	STX	DSCTMP+1
	STY	DSCTMP+2
	;LDWD	ARGMO		;GET POINTER TO OTHER STRING.
	LDA	ARGMO
	LDY	ARGMO+1
	JSR	FRETMP		;FREES FIRST DESC POINTER.
	;STXY	ARGMO
	STX	ARGMO
	STY	ARGMO+1
	TAX			;COPY COUNT INTO X.
	SEC
	SBC	DSCTMP		;WHICH IS GREATER. IF 0, ALL SET UP.
	BEQ	STASGN		;JUST PUT SIGN OF DIFFERENCE AWAY.
	LDA	#1
	BCC	STASGN		;SIGN IS POSITIVE.
	LDX	DSCTMP		;LENGTH OF FAC IS SHORTER.
	LDA	#255		;GET A MINUS 1 FOR NEGATIVES.
STASGN: STA	FACSGN		;KEEP FOR LATER.
	LDY	#255		;SET POINTER TO FIRST STRING. (ARG.)
	INX			;TO LOOP PROPERLY.
NXTCMP: INY
	DEX			;ANY CHARACTERS LEFT TO COMPARE?
	BNE	GETCMP		;NOT DONE YET.
	LDX	FACSGN		;USE SIGN OF LENGTH DIFFERENCE
				;SINCE ALL CHARACTERS ARE THE SAME.
QCOMP:	BMI	DOCMP		;C IS ALWAYS SET THEN.
	CLC
	BCC	DOCMP		;ALWAYS BRANCH.
GETCMP: ;LDADY	ARGMO		;GET NEXT CHAR TO COMPARE.
	LDA	(ARGMO),Y
	;
	;CMPDY	DSCTMP+1	;SAME?
	CMP	(DSCTMP+1),Y
	;
	BEQ	NXTCMP		;YEP. TRY FURTHER.
	LDX	#255		;SET A POSITIVE DIFFERENCE.
	BCS	DOCMP		;PUT STACK BACK TOGETHER.
	LDX	#1		;SET A NEGATIVE DIFFERENCE.
DOCMP:	INX			;-1 TO 1, 0 TO 2, 1 TO 4.
	TXA
	ROL	A
	AND	DOMASK
	BEQ	GOFLOT
	LDA	#255		;MAP 0 TO 0. ALL OTHERS TO -1.
GOFLOT: JMP	FLOAT		;FLOAT THE ONE-BYTE RESULT INTO FAC.
;
; THE "DIM" CODE SETS [DIMFLG] AND THEN FALLS INTO THE VARIABLE SEARCH
; ROUTINE, WHICH LOOKS AT DIMFLG AT THREE DIFFERENT POINTS.
;	1) IF AN ENTRY IS FOUND, "DIMFLG" BEING ON INDICATES
;		A "DOUBLY" DIMENSIONED VARIABLE.
;	2) WHEN A NEW ENTRY IS BEING BUILT "DIMFLG" BEING ON
;		INDICTAES THE INDICES SHOULD BE USED FOR THE
;		SIZE OF EACH INDEX. OTHERWISE THE DEFAULT OF TEN
;		IS USED.
;	3) WHEN THE BUILD ENTRY CODE FINISHES, ONLY IF "DIMFLG" IS OFF
;		WILL INDEXING BE DONE.
;
DIM3:	JSR	CHKCOM		;MUST BE A COMMA
DIM:	TAX			;SET [ACCX] NONZERO.
				;[ACCA] MUST BE NONZERO TO WORK RIGHT.
DIM1:	JSR	PTRGT1
DIMCON: JSR	CHRGOT		;GET LAST CHARACTER.
	BNE	DIM3
	RTS
;
; ROUTINE TO READ THE VARIABLE NAME AT THE CURRENT TEXT POSITION
; AND  PUT A POINTER TO ITS VALUE IN VARPNT. [TXTPTR]
; POINTS TO THE TERMINATING CHARCTER.. NOT THAT EVALUATING SUBSCRIPTS
; IN A VARIABLE NAME CAN CAUSE RECURSIVE CALLS TO "PTRGET" SO AT
; THAT POINT ALL VALUES MUST BE STORED ON THE STACK.
;
PTRGET: LDX	#0		;MAKE [ACCX]=0.
	JSR	CHRGOT		;RETRIEVE LAST CHARACTER.
PTRGT1: STX	DIMFLG		;STORE FLAG AWAY.
PTRGT2: STA	VARNAM
	JSR	CHRGOT		;GET CURRENT CHARACTER
				;MAYBE WITH FUNCTION BIT OFF.
	JSR	ISLETC		;CHECK FOR LETTER.
	BCS	PTRGT3		;MUST HAVE A LETTER.
INTERR: JMP	SNERR
PTRGT3: LDX	#0		;ASSUME NO SECOND CHARACTER.
	STX	VALTYP		;DEFAULT IS NUMERIC.
	STX	INTFLG		;ASSUME FLOATING.
	JSR	CHRGET		;GET FOLLOWING CHARACTER.
	BCC	ISSEC		;CARRY RESET BY CHRGET IF NUMERIC.
	JSR	ISLETC		;SET CARRY IF NOT ALPHABETIC.
	BCC	NOSEC		;ALLOW ALPHABETICS.
ISSEC:	TAX			;IT IS A NUMBER -- SAVE IN ACCX.
EATEM:	JSR	CHRGET		;LOOK AT NEXT CHARACTER.
	BCC	EATEM		;SKIP NUMERICS.
	JSR	ISLETC
	BCS	EATEM		;SKIP ALPHABETICS.
NOSEC:	CMP	#"$"		;IS IT A STRING?
	BNE	NOTSTR		;IF NOT, [VALTYP]=0.
	LDA	#255		;SET [VALTYP]=255 (STRING !).
	STA	VALTYP
	BNE	TURNON		;ALWAYS GOES.
NOTSTR: CMP	#"%"		;INTEGER VARIABLE?
	BNE	STRNAM		;NO.
	LDA	SUBFLG
	BNE	INTERR
	LDA	#128
	STA	INTFLG		;SET FLAG.
	ORA	VARNAM		;TURN ON BOTH HIGH BITS.
	STA	VARNAM
TURNON: TXA
	ORA	#128		;TURN ON MSB OF SECOND CHARACTER.
	TAX
	JSR	CHRGET		;GET CHARACTER AFTER $.
STRNAM: STX	VARNAM+1	;STORE AWAY SECOND CHARACTER.
	SEC
	ORA	SUBFLG		;ADD FLAG WHETHER TO ALLOW ARRAYS.
	SBC	#40		;(CHECK FOR "(") WON'T MATCH IF SUBFLG SET. 
	;JEQ	ISARY		;IT IS!
	BNE	$+5
	JMP	ISARY
	;
	;CLR	SUBFLG		;ALLOW SUBSCRIPTS AGAIN.
	LDA	#0
	STA	SUBFLG
	LDA	VARTAB		;PLACE TO START SEARCH.
	LDX	VARTAB+1
	LDY	#0
STXFND: STX	LOWTR+1
LOPFND: STA	LOWTR
	CPX	ARYTAB+1	;AT END OF TABLE YET?
	BNE	LOPFN
	CMP	ARYTAB
	BEQ	NOTFNS		;YES. WE COULDN'T FIND IT.
LOPFN:	LDA	VARNAM
	;CMPDY	LOWTR		;COMPARE HIGH ORDERS.
	CMP	(LOWTR),Y
	;
	BNE	NOTIT		;NO COMPARISON.
	LDA	VARNAM+1
	INY
	;CMPDY	LOWTR		;AND THE LOW PART?
	CMP	(LOWTR),Y
	;
	BEQ	FINPTR		;THAT'S IT ! THAT'S IT !
	DEY
NOTIT:	CLC
	LDA	LOWTR
	ADC	#6+ADDPRC	;MAKES NO DIF AMONG TYPES.
	BCC	LOPFND
	INX
	BNE	STXFND		;ALWAYS BRANCHES.

;
; TEST FOR A LETTER.	/ CARRY OFF= NOT A LETTER.
;			  CARRY ON= A LETTER.
;
ISLETC: CMP	#"A"
	BCC	ISLRTS		;IF LESS THAN "A", RET.
	SBC	#"Z"+1
	SEC
	SBC	#256-"Z"-1	;RESET CARRY IF [A] .GT. "Z".
ISLRTS: RTS			;RETURN TO CALLER.

NOTFNS: PLA			;CHECK WHO'S CALLING.
	PHA			;RESTORE IT.
	CMP	#ISVRET-1-(ISVRET-1)/256*256	;IS EVAL CALLING?
	BNE	NOTEVL		;NO, CARRY ON.
LDZR:	;LDWDI	ZERO		;SET UP PNTR TO SIMULATED ZERO.
	LDA	#ZERO
	LDY	#ZERO>>8
	RTS			;FOR STRINGS OR NUMERIC.
				;AND FOR INTEGERS TOO.
NOTEVL:
QSTAVR:
VAROK:	;LDWD	ARYTAB
	LDA	ARYTAB
	LDY	ARYTAB+1
	;STWD	LOWTR		;LOWEST THING TO MOVE.
	STA	LOWTR
	STY	LOWTR+1
	;LDWD	STREND		;GET HIGHEST ADDR TO MOVE.
	LDA	STREND
	LDY	STREND+1
	;STWD	HIGHTR
	STA	HIGHTR
	STY	HIGHTR+1
	CLC
	ADC	#6+ADDPRC
	BCC	NOTEVE
	INY
NOTEVE: ;STWD	HIGHDS		;PLACE TO STUFF IT.
	STA	HIGHDS
	STY	HIGHDS+1
	JSR	BLTU		;MOVE IT ALL.
				;NOTE [Y,A] HAS [HIGHDS] FOR REASON.
	;LDWD	HIGHDS		;AND SET UP
	LDA	HIGHDS
	LDY	HIGHDS+1
	INY
	;STWD	ARYTAB		;NEW START OF ARRAY TABLE.
	STA	ARYTAB
	STY	ARYTAB+1
	LDY	#0		;GET ADDR OF VARIABLE ENTRY.
	LDA	VARNAM
	;STADY	LOWTR
	STA	(LOWTR),Y
	;
	INY
	LDA	VARNAM+1
	;STADY	LOWTR		;STORE NAME OF VARIABLE.
	STA	(LOWTR),Y
	;
	LDA	#0
	INY
	;STADY	LOWTR
	STA	(LOWTR),Y
	;
	INY
	;STADY	LOWTR
	STA	(LOWTR),Y
	;
	INY
	;STADY	LOWTR
	STA	(LOWTR),Y
	;
	INY
	;STADY	LOWTR		;FOURTH ZERO FOR DEF FUNC.
	STA	(LOWTR),Y
	;
	INY
	;STADY	LOWTR
	STA	(LOWTR),Y
	;
FINPTR: LDA	LOWTR
	CLC
	ADC	#2
	LDY	LOWTR+1
	BCC	FINNOW
	INY
FINNOW: ;STWD	VARPNT		;THIS IS IT.
	STA	VARPNT
	STY	VARPNT+1
	RTS

FMAPTR: LDA	COUNT
	ASL	A
	ADC	#5		;POINT TO ENTRIES. C CLR'D BY ASL.
	ADC	LOWTR
	LDY	LOWTR+1
	BCC	JSRGM
	INY
JSRGM:	;STWD	ARYPNT
	STA	ARYPNT
	STY	ARYPNT+1
	;
	RTS

;N32768:	EXP	144,128,0,0	;-32768.
N32768:	BYTE	144,128,0,0		;FIXME?

;
; INTIDX READS A FORMULA FROM THE CURRENT POSITION AND
; TURNS IT INTO A POSITIVE INTEGER
; LEAVING THE RESULT IN FACMO&LO. NEGATIVE ARGUMENTS
; ARE NOT ALLOWED.
;
INTIDX: JSR	CHRGET
	JSR	FRMEVL		;GET A NUMBER
POSINT: JSR	CHKNUM
	LDA	FACSGN
	BMI	NONONO		;IF NEGATIVE, BLOW HIM OUT.
AYINT:	LDA	FACEXP
	CMP	#144		;FAC .GT. 32767?
	BCC	QINTGO
	;LDWDI	N32768		;GET ADDR OF -32768.
	LDA	#N32768
	LDY	#N32768>>8
	JSR	FCOMP		;SEE IF FAC=[[Y,A]].
NONONO: BNE	FCERR		;NO, FAC IS TOO BIG.
QINTGO: JMP	QINT		;GO TO QINT AND SHOVE IT.
;
; FORMAT OF ARRAYS IN CORE.
;
; DESCRIPTOR:
;	LOWBYTE = FIRST CHARACTER.
;	HIGHBYTE = SECOND CHARACTER (200 BIT IS STRING FLAG).
; LENGTH OF ARRAY IN CORE IN BYTES (INCLUDES EVERYTHING).
; NUMBER OF DIMENSIONS.
; FOR EACH DIMENSION STARTING WITH THE FIRST A LIST
; (2 BYTES EACH) OF THE MAX INDICE+1
; THE VALUES
;
ISARY:	LDA	DIMFLG
	ORA	INTFLG
	PHA			;SAVE [DIMFLG] FOR RECURSION.
	LDA	VALTYP
	PHA			;SAVE [VALTYP] FOR RECURSION.
	LDY	#0		;SET NUMBER OF DIMENSIONS TO ZERO.
INDLOP: TYA			;SAVE NUMBER OF DIMS.
	PHA
	;PSHWD	VARNAM		;SAVE LOOKS.
	LDA	VARNAM+1
	PHA
	LDA	VARNAM
	PHA
	;
	JSR	INTIDX		;EVALUATE INDICE INTO FACMO&LO.
	;PULWD	VARNAM		;GET BACK ALL... WE'RE HOME.
	PLA
	STA	VARNAM
	PLA
	STA	VARNAM+1
	;
	PLA			;(# OF DIMS).
	TAY
	TSX
	LDA	258,X
	PHA			;PUSH DIMFLG AND VALTYP FURTHER.
	LDA	257,X
	PHA
	LDA	INDICE		;PUT INDICE ONTO STACK.
	STA	258,X		;UNDER DIMFLG AND VALTYP.
	LDA	INDICE+1
	STA	257,X
	INY			;INCREMENT # OF DIMS.
	JSR	CHRGOT		;GET TERMINATING CHARACTER.
	CMP	#44		;A COMMA?
	BEQ	INDLOP		;YES.
	STY	COUNT		;SAVE COUNT OF DIMS.
	JSR	CHKCLS		;MUST BE CLOSED PAREN.
	PLA
	STA	VALTYP		;GET VALTYP AND
	PLA
	STA	INTFLG
	AND	#127
	STA	DIMFLG		;DIMFLG OFF STACK.
	LDX	ARYTAB		;PLACE TO START SEARCH.
	LDA	ARYTAB+1
LOPFDA: STX	LOWTR
	STA	LOWTR+1
	CMP	STREND+1	;END OF ARRAYS?
	BNE	LOPFDV
	CPX	STREND
	BEQ	NOTFDD		;A FINE THING! NO ARRAY!.
LOPFDV: LDY	#0
	;LDADY	LOWTR
	LDA	(LOWTR),Y
	;
	INY
	CMP	VARNAM		;COMPARE HIGH ORDERS.
	BNE	NMARY1		;NO WAY IS IT THIS. GET OUT OF HERE.
	LDA	VARNAM+1
	;CMPDY	LOWTR		;LOW ORDERS?
	CMP	(LOWTR),Y
	;
	BEQ	GOTARY		;WELL, HERE IT IS !!
NMARY1: INY
	;LDADY	LOWTR		;GET LENGTH.
	LDA	(LOWTR),Y
	;
	CLC
	ADC	LOWTR
	TAX
	INY
	;LDADY	LOWTR
	LDA	(LOWTR),Y
	;
	ADC	LOWTR+1
	BCC	LOPFDA		;ALWAYS BRANCHES.
BSERR:	LDX	#ERRBS		;GET BAD SUB ERROR NUMBER.
	BYTE	SKIP2
FCERR:	LDX	#ERRFC		;TOO BIG. "FUNCTION CALL" ERROR.
ERRGO3: JMP	ERROR
GOTARY: LDX	#ERRDD		;PERHAPS A "RE-DIMENSION" ERROR
	LDA	DIMFLG		;TEST THE DIMFLG
	BNE	ERRGO3
	JSR	FMAPTR
	LDA	COUNT		;GET NUMBER OF DIMS INPUT.
	LDY	#4
	;CMPDY	LOWTR		;# OF DIMS THE SAME?
	CMP	(LOWTR),Y
	;
	BNE	BSERR		;SAME SO GO GET DEFINITION.
	JMP	GETDEF

;
; HERE WHEN VARIABLE IS NOT FOUND IN THE ARRAY TABLE.
;
; BUILDING AN ENTRY.
;
;	PUT DOWN THE DESCRIPTOR.
;	SETUP NUMBER OF DIMENSIONS.
;	MAKE SURE THERE IS ROOM FOR THE NEW ENTRY.
;	REMEMBER "VARPNT".
;	TALLY=4.
;	SKIP 2 LOCS FOR LATER FILL IN OF SIZE.
; LOOP: GET AN INDICE
;	PUT DOWN NUMBER+1 AND INCREMENT VARPTR.
;	TALLY=TALLY*NUMBER+1.
;	DECREMENT NUMBER-DIMS.
;	BNE LOOP
;	CALL "REASON" WITH [Y,A] REFLECTING LAST LOC OF VARIABLE.
;	UPDATE STREND.
;	ZERO ALL.
;	MAKE TALLY INCLUDE MAXDIMS AND DESCRIPTOR.
;	PUT DOWN TALLY.
;	IF CALLED BY DIMENSION, RETURN.
;	OTHERWISE INDEX INTO THE VARIABLE AS IF IT
;	 WERE FOUND ON THE INITIAL SEARCH.
;
NOTFDD: JSR	FMAPTR		;FORM ARYPNT.
	JSR	REASON
	LDA	#0
	TAY
	STA	CURTOL+1
	LDX	#5
	LDA	VARNAM		;THIS CODE ONLY WORKS FOR INTPRC=1
	;STADY	LOWTR		;IF ADDPRC=1.
	STA	(LOWTR),Y
	;
	BPL	NOTFLT
	DEX
NOTFLT: INY
	LDA	VARNAM+1
	;STADY	LOWTR
	STA	(LOWTR),Y
	;
	BPL	STOMLT
	DEX
	DEX
STOMLT: STX	CURTOL
	LDA	COUNT
	INY
	INY
	INY
	;STADY	LOWTR		;SAVE NUMBER OF DIMENSIONS.
	STA	(LOWTR),Y
	;
LOPPTA: LDX	#11		;DEFAULT SIZE.
	LDA	#0
	BIT	DIMFLG
	BVC	NOTDIM		;NOT IN A DIM STATEMENT.
	PLA			;GET LOW ORDER OF INDICE.
	CLC
	ADC	#1
	TAX
	PLA			;GET HIGH PART OF INDICE.
	ADC	#0
NOTDIM: INY
	;STADY	LOWTR		;STORE HIGH PART OF INDICE.
	STA	(LOWTR),Y
	;
	INY
	TXA
	;STADY	LOWTR		;STORE LOW ORDER OF INDICE.
	STA	(LOWTR),Y
	;
	JSR	UMULT		;[X,A]=[CURTOL]*[LOWTR,Y]
	STX	CURTOL		;SAVE NEW TALLY.
	STA	CURTOL+1
	LDY	INDEX
	DEC	COUNT		;ANY MORE INDICES LEFT?
	BNE	LOPPTA		;YES.
	ADC	ARYPNT+1
	BCS	OMERR1		;OVERFLOW.
	STA	ARYPNT+1	;COMPUTE WHERE TO ZERO.
	TAY
	TXA
	ADC	ARYPNT
	BCC	GREASE
	INY
	BEQ	OMERR1
GREASE: JSR	REASON		;GET ROOM.
	;STWD	STREND		;NEW END OF STORAGE.
	STA	STREND
	STY	STREND+1
	LDA	#0		;STORING [ACCA] IS FASTER THAN CLEAR.
	INC	CURTOL+1
	LDY	CURTOL
	BEQ	DECCUR
ZERITA: DEY
	;STADY	ARYPNT
	STA	(ARYPNT),Y
	;
	BNE	ZERITA		;NO. CONTINUE.
DECCUR: DEC	ARYPNT+1
	DEC	CURTOL+1
	BNE	ZERITA		;DO ANOTHER BLOCK.
	INC	ARYPNT+1	;BUMP BACK UP. WILL USE LATER.
	SEC
	LDA	STREND		;RESTORE [ACCA].
	SBC	LOWTR		;DETERMINE LENGTH.
	LDY	#2
	;STADY	LOWTR		;LOW.
	STA	(LOWTR),Y
	;
	LDA	STREND+1
	INY
	SBC	LOWTR+1
	;STADY	LOWTR		;HIGH.
	STA	(LOWTR),Y
	;
	LDA	DIMFLG
	BNE	DIMRTS		;BYE.
	INY
;
; AT THIS POINT [LOWTR,Y] POINTS BEYOND THE SIZE TO THE NUMBER OF
; DIMENSIONS. STRATEGY:
;	NUMDIM=NUMBER OF DIMENSIONS.
;	CURTOL=0.
; INLPNM:GET A NEW INDICE.
;	MAKE SURE INDICE IS NOT TOO BIG.
;	MULTIPLY CURTOL BY CURMAX.
;	ADD INDICE TO CURTOL.
;	NUMDIM=NUMDIM-1.
;	BNE	INLPNM.
;	USE [CURTOL]*4 AS OFFSET.
;
GETDEF: ;LDADY	LOWTR
	LDA	(LOWTR),Y
	;
	STA	COUNT		;SAVE A COUNTER.
	LDA	#0		;ZERO [CURTOL].
	STA	CURTOL
INLPNM: STA	CURTOL+1
	INY
	PLA			;GET LOW INDICE.
	TAX
	STA	INDICE
	PLA			;AND THE HIGH PART
	STA	INDICE+1
	;CMPDY	LOWTR		;COMPARE WITH MAX INDICE.
	CMP	(LOWTR),Y
	;
	BCC	INLPN2
	BNE	BSERR7		;IF GREATER, "BAD SUBSCRIPT" ERROR.
	INY
	TXA
	;CMPDY	LOWTR
	CMP	(LOWTR),Y
	;
	BCC	INLPN1
BSERR7: JMP	BSERR
OMERR1: JMP	OMERR
INLPN2: INY
INLPN1: LDA	CURTOL+1	;DON'T MULTIPLY IF CURTOL=0.
	ORA	CURTOL
	CLC			;PREPARE TO GET INDICE BACK.
	BEQ	ADDIND		;GET HIGH PART OF INDICE BACK.
	JSR	UMULT		;MULTIPLY [CURTOL] BY [LOWTR,Y,Y+1].
	TXA
	ADC	INDICE		;ADD IN [INDICE].
	TAX
	TYA
	LDY	INDEX1
ADDIND: ADC	INDICE+1
	STX	CURTOL
	DEC	COUNT		;ANY MORE?
	BNE	INLPNM		;YES.
	STA	CURTOL+1	;FIX ARRAY BUG ****
	LDX	#5		;THIS CODE ONLY WORKS FOR INTPRC=1
	LDA	VARNAM		;IF ADDPRC=1.
	BPL	NOTFL1
	DEX
NOTFL1: LDA	VARNAM+1
	BPL	STOML1
	DEX
	DEX
STOML1: STX	ADDEND
	LDA	#0
	JSR	UMULTD		;ON RTS, A&Y=HI . X=LO.
	TXA
	ADC	ARYPNT
	STA	VARPNT
	TYA
	ADC	ARYPNT+1
	STA	VARPNT+1
	TAY
	LDA	VARPNT
DIMRTS: RTS			;RETURN TO CALLER.
	;TWO BYTE UNSIGNED INTEGER MULTIPLY.
	;THIS IS FOR MULTIPLY DIMENSIONED ARRAYS.
	; [X,Y]=[X,A]=[CURTOL]*[LOWTR,Y,Y+1].
UMULT:	STY	INDEX
	;LDADY	LOWTR
	LDA	(LOWTR),Y
	;
	STA	ADDEND		;LOW, THEN HIGH.
	DEY
	;LDADY	LOWTR		;PUT [LOWTR,Y,Y+1] IN FASTER MEMORY.
	LDA	(LOWTR),Y
	;
UMULTD: STA	ADDEND+1
	LDA	#16
	STA	DECCNT
	LDX	#0		;CLR THE ACCS.
	LDY	#0		;RESULT INITIALLY ZERO.
UMULTC: TXA
	ASL	A		;MULTIPLY BY TWO.
	TAX
	TYA
	ROL	A
	TAY
	BCS	OMERR1		;TWO MUCH !
	ASL	CURTOL
	ROL	CURTOL+1
	BCC	UMLCNT		;NOTHING IN THIS POSITION TO MULTIPLY.
	CLC
	TXA
	ADC	ADDEND
	TAX
	TYA
	ADC	ADDEND+1
	TAY
	BCS	OMERR1		;MAN, JUST TOO MUCH !
UMLCNT: DEC	DECCNT		;DONE?
	BNE	UMULTC		;KEEP IT UP.
UMLRTS: RTS			;YES, ALL DONE.

FRE:	LDA	VALTYP
	BEQ	NOFREF
	JSR	FREFAC
NOFREF: JSR	GARBA2
	SEC
	LDA	FRETOP		;WE WANT
	SBC	STREND		;[FRETOP]-[STREND].
	TAY
	LDA	FRETOP+1
	SBC	STREND+1

GIVAYF: LDX	#0
	STX	VALTYP
	;STWD	FACHO
	STA	FACHO
	STY	FACHO+1
	LDX	#144		;SET EXPONENT TO 2^16.
	JMP	FLOATS		;TURN IT TO A FLOATING PNT #.

POS:	LDY	TRMPOS		;GET POSITION.
SNGFLT: LDA	#0
	BEQ	GIVAYF		;FLOAT IT.
;
; NOTE ONLY SINGLE ARGUMENTS ARE ALLOWED TO FUNCTIONS
; AND FUNCTIONS MUST BE OF THE SINGLE LINE FORM:
;	DEF FNA(X)=X^2+X-2
; NO STRINGS CAN BE INVOLVED WITH THESE FUNCTIONS.
;
; IDEA: CREATE A SIMPLE VARIABLE ENTRY
; WHOSE FIRST CHARACTER HAS THE 200 BIT SET.
; THE VALUE WILL BE:
;
;	A TEXT PNTR TO THE FORMULA.
;	A PNTR TO THE ARGUMENT VARIABLE.
;
; FUNCTION NAMES CAN BE LIKE "FNA4".
;
;
; SUBROUTINE TO SEE IF WE ARE IN DIRECT MODE.
; AND COMPLAIN IF SO.
;
ERRDIR: LDX	CURLIN+1	;DIR MODE HAS [CURLIN]=0,255
	INX			;SO NOW, IS RESULT ZERO?
	BNE	DIMRTS		;YES.
	LDX	#ERRID		;INPUT DIRECT ERROR CODE.
	BYTE	SKIP2
ERRGUF: LDX	#ERRUF		;USER DEFINED FUNCTION NEVER DEFINED
ERRGO1: JMP	ERROR

DEF:	JSR	GETFNM		;GET A PNTR TO THE FUNCTION.
	JSR	ERRDIR
	JSR	CHKOPN		;MUST HAVE "(".
	LDA	#128
	STA	SUBFLG		;PROHIBIT SUBSCRIPTED VARIABLES.
	JSR	PTRGET		;GET PNTR TO ARGUMENT.
	JSR	CHKNUM		;IS IT A NUMBER?
	JSR	CHKCLS		;MUST HAVE ")"
	;SYNCHK	EQULTK		;MUST HAVE "=".
	LDA	#EQULTK
	JSR	SYNCHR
	;
	PHA			;PUT CRAZY BYTE ON.
	;PSHWD	VARPNT
	LDA	VARPNT+1
	PHA
	LDA	VARPNT
	PHA
	;
	;PSHWD	TXTPTR
	LDA	TXTPTR+1
	PHA
	LDA	TXTPTR
	PHA
	;
	JSR	DATA
	JMP	DEFFIN
;
; SUBROUTINE TO GET A PNTR TO A FUNCTION NAME.
;
GETFNM: ;SYNCHK	FNTK		;MUST START WITH FN.
	LDA	#FNTK
	JSR	SYNCHR
	;
	ORA	#128		;PUT FUNCTION BIT ON.
	STA	SUBFLG
	JSR	PTRGT2		;GET POINTER TO FUNCTION OR CREATE ANEW.
	;STWD	DEFPNT
	STA	DEFPNT
	STY	DEFPNT+1
	JMP	CHKNUM		;MAKE SURE IT'S NOT A STRING AND RETURN.

FNDOER: JSR	GETFNM		;GET THE FUNCTION'S NAME.
	;PSHWD	DEFPNT
	LDA	DEFPNT+1
	PHA
	LDA	DEFPNT
	PHA
	;
	JSR	PARCHK		;EVALUATE PARAMETER.
	JSR	CHKNUM
	;PULWD	DEFPNT
	PLA
	STA	DEFPNT
	PLA
	STA	DEFPNT+1
	;
	LDY	#2
	;LDADY	DEFPNT		;GET POINTER TO VARIABLE.
	LDA	(DEFPNT),Y
	;
	STA	VARPNT		;SAVE VARIABLE POINTER.
	TAX
	INY
	;LDADY	DEFPNT
	LDA	(DEFPNT),Y
	;
	BEQ	ERRGUF
	STA	VARPNT+1
	INY			;SINCE DEF USES ONLY 4.
DEFSTF: ;LDADY	VARPNT
	LDA	(VARPNT),Y
	;
	PHA			;PUSH IT ALL ON STACK.
	DEY			;SINCE WE ARE RECURSING MAYBE.
	BPL	DEFSTF
	LDY	VARPNT+1
	JSR	MOVMF		;PUT CURRENT FAC INTO OUR ARG VARIABLE.
	;PSHWD	TXTPTR		;SAVE TEXT POINTER.
	LDA	TXTPTR+1
	PHA
	LDA	TXTPTR
	PHA
	;
	;LDADY	DEFPNT		;PNTR TO FUNCTION.
	LDA	(DEFPNT),Y
	;
	STA	TXTPTR
	INY
	;LDADY	DEFPNT
	LDA	(DEFPNT),Y
	;
	STA	TXTPTR+1
	;PSHWD	VARPNT		;SAVE VARIABLE POINTER.
	LDA	VARPNT+1
	PHA
	LDA	VARPNT
	PHA
	;
	JSR	FRMNUM		;EVALUATE FORMULA AND CHECK NUMERIC.
	;PULWD	DEFPNT
	PLA
	STA	DEFPNT
	PLA
	STA	DEFPNT+1
	;
	JSR	CHRGOT
	;JNE	SNERR		;IT DIDN'T TERMINATE. HUH?
	BEQ	$+5
	JMP	SNERR
	;
	;PULWD	TXTPTR		;RESTORE TEXT PNTR.
	PLA
	STA	TXTPTR
	PLA
	STA	TXTPTR+1
	;
DEFFIN: LDY	#0
	PLA			;GET OLD ARG VALUE OFF STACK
	;STADY	DEFPNT		;AND PUT IT BACK IN VARIABLE.
	STA	(DEFPNT),Y
	;
	PLA
	INY
	;STADY	DEFPNT
	STA	(DEFPNT),Y
	;
	PLA
	INY
	;STADY	DEFPNT
	STA	(DEFPNT),Y
	;
	PLA
	INY
	;STADY	DEFPNT
	STA	(DEFPNT),Y
	;
	PLA
	INY	
	;STADY	DEFPNT
	STA	(DEFPNT),Y
	;
DEFRTS: RTS
;
; THE STR$ FUNCTION TAKES A NUMBER AND GIVES A STRING
; WITH THE CHARACTERS THE OUTPUT OF THE NUMBER
; WOULD HAVE GIVEN.
;
STR:	JSR	CHKNUM		;ARG HAS TO BE NUMERIC.
	LDY	#0
	JSR	FOUTC		;DO ITS OUTPUT.
	PLA
	PLA
TIMSTR:	;LDWDI	LOFBUF
	LDA	#LOFBUF
	LDY	#LOFBUF>>8
	;
	BEQ	STRLIT		;SCAN IT AND TURN IT INTO A STRING.
;
; "STRINI" GET STRING SPACE FOR THE CREATION OF A STRING AND
; CREATES A DESCRIPTOR FOR IT IN "DSCTMP".
;
STRINI: ;LDXY	FACMO		;GET FACMO TO STORE IN DSCPNT.
	LDX	FACMO
	LDY	FACMO+1
	;
	;STXY	DSCPNT		;RETAIN THE DESCRIPTOR POINTER.
	STX	DSCPNT
	STY	DSCPNT+1
	;
STRSPA: JSR	GETSPA		;GET STRING SPACE.
	;STXY	DSCTMP+1	;SAVE LOCATION.
	STX	DSCTMP+1
	STY	DSCTMP+2
	;
	STA	DSCTMP		;SAVE LENGTH.
	RTS			;ALL DONE.
;
; "STRLT2" TAKES THE STRING LITERAL WHOSE FIRST CHARACTER
; IS POINTED TO BY [Y,A] AND BUILDS A DESCRIPTOR FOR IT.
; THE DESCRIPTOR IS INITIALLY BUILT IN "DSCTMP", BUT "PUTNEW"
; TRANSFERS IT INTO A TEMPORARY AND LEAVES A POINTER
; AT THE TEMPORARY IN FACMO&LO. THE CHARACTERS OTHER THAN
; ZERO THAT TERMINATE THE STRING SHOULD BE SET UP IN "CHARAC"
; AND "ENDCHR". IF THE TERMINATOR IS A QUOTE, THE QUOTE IS SKIPPED
; OVER. LEADING QUOTES SHOULD BE SKIPPED BEFORE JSR. ON RETURN
; THE CHARACTER AFTER THE STRING LITERAL IS POINTED TO
; BY [STRNG2].
;
STRLIT: LDX	#34		;ASSUME STRING ENDS ON QUOTE.
	STX	CHARAC
	STX	ENDCHR
STRLT2: ;STWD	STRNG1		;SAVE POINTER TO STRING.
	STA	STRNG1
	STY	STRNG1+1
	;
	;STWD	DSCTMP+1	;IN CASE NO STRCPY.
	STA	DSCTMP+1
	STY	DSCTMP+2
	;
	LDY	#255		;INITIALIZE CHARACTER COUNT.
STRGET: INY
	;LDADY	STRNG1		;GET CHARACTER.
	LDA	(STRNG1),Y
	;
	BEQ	STRFI1		;IF ZERO.
	CMP	CHARAC		;THIS TERMINATOR?
	BEQ	STRFIN		;YES.
	CMP	ENDCHR
	BNE	STRGET		;LOOK FURTHER.
STRFIN: CMP	#34		;QUOTE?
	BEQ	STRFI2
STRFI1: CLC			;NO, BACK UP.
STRFI2: STY	DSCTMP		;RETAIN COUNT.
	TYA
	ADC	STRNG1		;WISHING TO SET [TXTPTR].
	STA	STRNG2
	LDX	STRNG1+1
	BCC	STRST2
	INX
STRST2: STX	STRNG2+1
	LDA	STRNG1+1	;IF PAGE 0, COPY SINCE IT IS EITHER
				;A STRING CONSTANT IN BUF OR A STR$
				;RESULT IN LOFBUF
	BEQ	STRCP
	CMP	#BUFPAG
	BNE	PUTNEW
STRCP:	TYA
	JSR	STRINI
	;LDXY	STRNG1
	LDX	STRNG1
	LDY	STRNG1+1
	;
	JSR	MOVSTR		;MOVE STRING.
;
; SOME STRING FUNCTION IS RETURNING A RESULT IN DSCTMP.
; SETUP A TEMP DESCRIPTOR WITH DSCTMP IN IT.
; PUT A POINTER TO THE DESCRIPTOR IN FACMO&LO AND FLAG THE
; RESULT AS TYPE STRING.
;
PUTNEW: LDX	TEMPPT		;POINTER TO FIRST FREE TEMP.
	CPX	#TEMPST+STRSIZ*NUMTMP
	BNE	PUTNW1
	LDX	#ERRST		;STRING TEMPORARY ERROR.
ERRGO2: JMP	ERROR		;GO TELL HIM.
PUTNW1: LDA	DSCTMP
	STA	0,X
	LDA	DSCTMP+1
	STA	1,X
	LDA	DSCTMP+2
	STA	2,X
	LDY	#0
	;STXY	FACMO
	STX	FACMO
	STY	FACMO+1
	;
	STY	FACOV
	DEY
	STY	VALTYP		;TYPE IS "STRING".
	STX	LASTPT		;SET POINTER TO LAST-USED TEMP.
	INX
	INX
	INX			;POINT FURTHER.
	STX	TEMPPT		;SAVE POINTER TO NEXT TEMP IF ANY.
	RTS			;ALL DONE.
;
; GETSPA - GET SPACE FOR CHARACTER STRING.
; MAY FORCE GARBAGE COLLECTION.
;
; # OF CHARACTERS (BYTES) IN ACCA.
; RETURNS WITH POINTER IN [Y,X]. OTHERWISE (IF CAN'T GET
; SPACE) BLOWS OFF TO "OUT OF STRING SPACE" TYPE ERROR.
; ALSO PRESERVES [ACCA] AND SETS [FRESPC]=[Y,X]=PNTR AT SPACE.
;
GETSPA: LSR	GARBFL		;SIGNAL NO GARBAGE COLLECTION YET.
TRYAG2: PHA			;SAVE FOR LATER.
	EOR	#255
	SEC			;ADD ONE TO COMPLETE NEGATION.
	ADC	FRETOP
	LDY	FRETOP+1
	BCS	TRYAG3
	DEY
TRYAG3: CPY	STREND+1	;COMPARE HIGH ORDERS.
	BCC	GARBAG		;MAKE ROOM FOR MORE.
	BNE	STRFRE		;SAVE NEW FRETOP.
	CMP	STREND		;COMPARE LOW ORDERS.
	BCC	GARBAG		;CLEAN UP.
STRFRE: ;STWD	FRETOP		;SAVE NEW [FRETOP].
	STA	FRETOP
	STY	FRETOP+1
	;STWD	FRESPC		;PUT IT THERE OLD MAN.
	STA	FRESPC
	STY	FRESPC+1
	TAX			;PRESERVE A IN X.
	PLA			;GET COUNT BACK IN ACCA.
	RTS			;ALL DONE.
GARBAG: LDX	#ERROM		;"OUT OF STRING SPACE"
	LDA	GARBFL
	BMI	ERRGO2
	JSR	GARBA2
	LDA	#128
	STA	GARBFL
	PLA			;GET BACK STRING LENGTH.
	BNE	TRYAG2		;ALWAYS BRANCHES.
GARBA2:				;START FROM TOP DOWN.
	LDX	MEMSIZ
	LDA	MEMSIZ+1
FNDVAR: STX	FRETOP		;LIKE SO.
	STA	FRETOP+1
	LDY	#0
	STY	GRBPNT+1
	STY	GRBPNT		;BOTH BYTES SET TO ZERO (FIX BUG)
	;LDWX	STREND
	LDA	STREND
	LDX	STREND+1
	;STWX	GRBTOP
	STA	GRBTOP
	STX	GRBTOP+1
	;LDWXI	TEMPST
	LDA	TEMPST
	LDX	TEMPST+1
	;STWX	INDEX1
	STA	INDEX1
	STX	INDEX1+1
TVAR:	CMP	TEMPPT		;DONE WITH TEMPS?
	BEQ	SVARS		;YEP.
	JSR	DVAR
	BEQ	TVAR		;LOOP.
SVARS:	LDA	#6+ADDPRC
	STA	FOUR6
	;LDWX	VARTAB		;GET START OF SIMPLE VARIABLES.
	LDA	VARTAB
	LDX	VARTAB+1
	;STWX	INDEX1
	STA	INDEX1
	STX	INDEX1+1
SVAR:	CPX	ARYTAB+1	;DONE WITH SIMPLE VARIABLES?
	BNE	SVARGO		;NO.
	CMP	ARYTAB
	BEQ	ARYVAR		;YEP.
SVARGO: JSR	DVARS		;DO IT , AGAIN.
	BEQ	SVAR		;LOOP.
ARYVAR: ;STWX	ARYPNT		;SAVE FOR ADDITION.
	STA	ARYPNT
	STX	ARYPNT+1
	LDA	#STRSIZ
	STA	FOUR6
ARYVA2: ;LDWX	ARYPNT		;GET THE POINTER TO VARIABLE.
	LDA	ARYPNT
	LDX	ARYPNT+1
ARYVA3: CPX	STREND+1	;DONE WITH ARRAYS?
	BNE	ARYVGO		;NO.
	CMP	STREND
	;JEQ	GRBPAS		;YES, GO FINISH UP.
	BNE	$+5
	JMP	GRBPAS
	;
ARYVGO: ;STWX	INDEX1
	STA	INDEX1
	STX	INDEX1+1
	LDY	#1-ADDPRC
	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	TAX
	INY
	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	PHP
	INY
	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	ADC	ARYPNT
	STA	ARYPNT		;FORM POINTER TO NEXT ARRAY VAR.
	INY
	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	ADC	ARYPNT+1
	STA	ARYPNT+1
	PLP
	BPL	ARYVA2
	TXA
	BMI	ARYVA2
	INY
	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	LDY	#0		;RESET INDEX Y.
	ASL	A
	ADC	#5		;CARRY IS OFF AND OFF AFTER ADD.
	ADC	INDEX1
	STA	INDEX1
	BCC	ARYGET
	INC	INDEX1+1
ARYGET: LDX	INDEX1+1
ARYSTR: CPX	ARYPNT+1	;END OF THE ARRAY?
	BNE	GOGO
	CMP	ARYPNT
	BEQ	ARYVA3		;YES.
GOGO:	JSR	DVAR
	BEQ	ARYSTR		;CYCLE.
DVARS:
	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	BMI	DVARTS
	INY
	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	BPL	DVARTS
	INY
DVAR:	;LDADY	INDEX1		;IS LENGTH=0?
	LDA	(INDEX1),Y
	;
	BEQ	DVARTS		;YES, RETURN.
	INY
	;LDADY	INDEX1		;GET LOW(ADR).
	LDA	(INDEX1),Y
	;
	TAX
	INY
	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	CMP	FRETOP+1	;COMPARE HIGHS.
	BCC	DVAR2		;IF THIS STRING'S PNTR .GE. [FRETOP]
	BNE	DVARTS		;NO NEED TO MESS WITH IT FURTHER.
	CPX	FRETOP		;COMPARE LOWS.
	BCS	DVARTS
DVAR2:	CMP	GRBTOP+1
	BCC	DVARTS		;IF THIS STRING IS BELOW PREVIOUS,
				;FORGET IT.
	BNE	DVAR3
	CPX	GRBTOP		;COMPARE LOW ORDERS.
	BCC	DVARTS		;[X,A] .LE. [GRBTOP].
DVAR3:	STX	GRBTOP
	STA	GRBTOP+1
	;LDWX	INDEX1
	LDA	INDEX1
	LDX	INDEX1+1
	;STWX	GRBPNT
	STA	GRBPNT
	STX	GRBPNT+1
	LDA	FOUR6
	STA	SIZE
DVARTS: LDA	FOUR6
	CLC
	ADC	INDEX1
	STA	INDEX1
	BCC	GRBRTS
	INC	INDEX1+1
GRBRTS: LDX	INDEX1+1
	LDY	#0
	RTS			;DONE.
;
; HERE WHEN MADE ONE COMPLETE PASS THROUGH STRING VARIABLES.
;
GRBPAS: LDA	GRBPNT+1	;VARIABLE POINTER.
	ORA	GRBPNT
	BEQ	GRBRTS		;ALL DONE.
	LDA	SIZE
	AND	#4		;LEAVES C OFF.
	LSR	A
	TAY
	STA	SIZE
	;LDADY	GRBPNT
	LDA	(GRBPNT),Y
	;
				;NOTE: GRBTOP=LOWTR SO NO NEED TO SET LOWTR.
	ADC	LOWTR
	STA	HIGHTR
	LDA	LOWTR+1
	ADC	#0
	STA	HIGHTR+1
	;LDWX	FRETOP
	LDA	FRETOP
	LDX	FRETOP+1
	;STWX	HIGHDS		;WHERE IT ALL GOES.
	STA	HIGHDS
	STX	HIGHDS+1
	JSR	BLTUC
	LDY	SIZE
	INY
	LDA	HIGHDS		;GET POSITION OF START OF RESULT.
	;STADY	GRBPNT
	STA	(GRBPNT),Y
	;
	TAX
	INC	HIGHDS+1
	LDA	HIGHDS+1
	INY
	;STADY	GRBPNT		;CHANGE ADDR OF STRING IN VAR.
	STA	(GRBPNT),Y
	;
	JMP	FNDVAR		;GO TO FNDVAR WITH SOMETHING FOR
				;[FRETOP].
;
; THE FOLLOWING ROUTINE CONCATENATES TWO STRINGS.
; THE FAC CONTAINS THE FIRST ONE AT THIS POINT.
; [TXTPTR] POINTS TO THE + SIGN.
;
CAT:	LDA	FACLO		;PSH HIGH ORDER ONTO STACK.
	PHA
	LDA	FACMO		;AND THE LOW.
	PHA
	JSR	EVAL		;CAN COME BACK HERE SINCE
				;OPERATOR IS KNOWN.
	JSR	CHKSTR		;RESULT MUST BE STRING.
	PLA
	STA	STRNG1		;GET HIGH ORDER OF OLD DESC.
	PLA
	STA	STRNG1+1
	LDY	#0
	;LDADY	STRNG1		;GET LENGTH OF OLD STRING.
	LDA	(STRNG1),Y
	;
	CLC
	;ADCDY	FACMO
	ADC	(FACMO),Y
	;
	BCC	SIZEOK		;RESULT IS LESS THAN 256.
	LDX	#ERRLS		;ERROR "LONG STRING".
	JMP	ERROR
SIZEOK: JSR	STRINI		;INITIALIZE STRING.
	JSR	MOVINS		;MOVE IT.
	;LDWD	DSCPNT		;GET POINTER TO SECOND.
	LDA	DSCPNT
	LDY	DSCPNT+1
	JSR	FRETMP		;FREE IT.
	JSR	MOVDO
	;LDWD	STRNG1
	LDA	STRNG1
	LDY	STRNG1+1
	JSR	FRETMP
	JSR	PUTNEW
	JMP	TSTOP		;"CAT" REENTERS FORM EVAL AT TSTOP.

MOVINS: LDY	#0		;GET ADDR OF STRING.
	;LDADY	STRNG1
	LDA	(STRNG1),Y
	;
	PHA
	INY
	;LDADY	STRNG1
	LDA	(STRNG1),Y
	;
	TAX
	INY
	;LDADY	STRNG1
	LDA	(STRNG1),Y
	;
	TAY
	PLA
MOVSTR: ;STXY	INDEX
	STX	INDEX
	STY	INDEX+1
MOVDO:	TAY
	BEQ	MVDONE
	PHA
MOVLP:	DEY
	;LDADY	INDEX
	LDA	(INDEX),Y
	;
	;STADY	FRESPC
	STA	(FRESPC),Y
	;
QMOVE:	TYA
	BNE	MOVLP
	PLA
MVDONE: CLC
	ADC	FRESPC
	STA	FRESPC
	BCC	MVSTRT
	INC	FRESPC+1
MVSTRT: RTS
;
; "FRETMP" IS PASSED A STRING DESCRIPTOR PNTR IN [Y,A].
; A CHECK IS MADE TO SEE IF THE STRING DESCRIPTOR POINTS TO THE LAST
; TEMPORARY DESCRIPTOR ALLOCATED BY PUTNEW.
; IF SO, THE TEMPORARY IS FREED UP BY THE UPDATING OF [TEMPPT].
; IF A TEMP IS FREED UP, A FURTHER CHECK SEES IF THE STRING DATA THAT
; THAT STRING TEMP PNT'D TO IS THE LOWEST PART OF STRING SPACE IN USE.
; IF SO, [FRETOP] IS UPDATED TO REFLECT THE FACT THE FACT THAT THE SPACE
; IS NO LONGER IN USE.
; THE ADDR OF THE ACTUAL STRING IS RETURNED IN [Y,X] AND
; ITS LENGTH IN ACCA.
;
FRESTR: JSR	CHKSTR		;MAKE SURE ITS A STRING.
FREFAC: ;LDWD	FACMO		;FREE UP STR PNT'D TO BY FAC.
	LDA	FACMO
	LDY	FACMO+1
FRETMP: ;STWD	INDEX		;GET LENGTH FOR LATER.
	STA	INDEX
	STY	INDEX+1
	JSR	FRETMS		;FREE UP THE TEMPORARY DESC.
	PHP			;SAVE CODES.
	LDY	#0		;PREP TO GET STUFF.
	;LDADY	INDEX		;GET COUNT AND
	LDA	(INDEX),Y
	;
	PHA			;SAVE IT.
	INY
	;LDADY	INDEX
	LDA	(INDEX),Y
	;
	TAX			;SAVE LOW ORDER.
	INY
	;LDADY	INDEX
	LDA	(INDEX),Y
	;
	TAY			;SAVE HIGH ORDER.
	PLA
	PLP			;RETURN STATUS.
	BNE	FRETRT
	CPY	FRETOP+1	;STRING IS LAST ONE IN?
	BNE	FRETRT
	CPX	FRETOP
	BNE	FRETRT
	PHA
	CLC
	ADC	FRETOP
	STA	FRETOP
	BCC	FREPLA
	INC	FRETOP+1
FREPLA: PLA			;GET COUNT BACK.
FRETRT: ;STXY	INDEX		;SAVE FOR LATER USE.
	STX	INDEX
	STY	INDEX+1
	RTS
FRETMS: CPY	LASTPT+1	;LAST ENTRY TO TEMP? 
	BNE	FRERTS
	CMP	LASTPT
	BNE	FRERTS
	STA	TEMPPT
	SBC	#STRSIZ		;POINT TO LAST ONE.
	STA	LASTPT		;UPDATE TEMP PNTR.
	LDY	#0		;ALSO CLEARS ZFLG SO WE DO REST OF FRETMP.
FRERTS: RTS			;ALL DONE.
;
; CHR$(#) CREATES A STRING WHICH CONTAINS AS ITS ONLY
; CHARACTER THE ASCII EQUIVALENT OF THE INTEGER ARGUMENT (#)
; WHICH MUST BE .LT. 255.
;
CHR:	JSR	CONINT		;GET INTEGER IN RANGE.
	TXA
	PHA
	LDA	#1		;ONE-CHARACTER STRING.
	JSR	STRSPA		;GET SPACE FOR STRING.
	PLA
	LDY	#0
	;STADY	DSCTMP+1
	STA	(DSCTMP+1),Y
	;
	PLA			;GET RID OF "CHKNUM" RETURN ADDR.
	PLA
RLZRET: JMP	PUTNEW		;SETUP FAC TO POINT TO DESC.
;
; THE FOLLOWING IS THE LEFT$($,#) FUNCTION.
; IT TAKES THE LEFTMOST # CHARACTERS OF THE STRING.
; IF # .GT. THE LEN OF THE STRING, IT RETURNS THE WHOLE STRING.
;
LEFT:	JSR	PREAM		;TEST PARAMETERS.
	;CMPDY	DSCPNT
	CMP	(DSCPNT),Y
	;
	TYA
RLEFT:	BCC	RLEFT1
	;LDADY	DSCPNT
	LDA	(DSCPNT),Y
	;
	TAX			;PUT LENGTH INTO X.
	TYA			;ZERO A, THE OFFSET.
RLEFT1: PHA			;SAVE OFFSET.
RLEFT2: TXA
RLEFT3: PHA			;SAVE LENGTH.
	JSR	STRSPA		;GET SPACE.
	;LDWD	DSCPNT
	LDA	DSCPNT
	LDY	DSCPNT+1
	JSR	FRETMP
	PLA
	TAY
	PLA
	CLC
	ADC	INDEX		;COMPUTE WHERE TO COPY.
	STA	INDEX
	BCC	PULMOR
	INC	INDEX+1
PULMOR: TYA
	JSR	MOVDO		;GO MOVE IT.
	JMP	PUTNEW
RIGHT:	JSR	PREAM
	CLC			;[LENGTH DES'D]-[LENGTH]-1.
	;SBCDY	DSCPNT
	SBC	(DSCPNT),Y
	;
	EOR	#255		;NEGATE.
	JMP	RLEFT
;
; MID ($,#) RETURNS STRING WITH CHARS FROM # POSITION
; ONWARD. IF # .GT. LEN ($) THEN RETURN NULL STRING.
; MID ($,#,#) RETURNS STRING WITH CHARACTERS FROM
; # POSITION FOR #2 CHARACTERS. IF #2 GOES PAST END OF STRING
; RETURN AS MUCH AS POSSIBLE.
;
MID:	LDA	#255		;DEFAULT.
	STA	FACLO		;SAVE FOR LATER COMPARE.
	JSR	CHRGOT		;GET CURRENT CHARACTER.
	CMP	#41		;IS IT A RIGHT PAREN )?
	BEQ	MID2		;NO THIRD PARAM.
	JSR	CHKCOM		;MUST HAVE COMMA.
	JSR	GETBYT		;GET THE LENGTH INTO "FACLO".
MID2:	JSR	PREAM		;CHECK IT OUT.
	BEQ	GOFUC		;THERE IS NO POSTION 0
	DEX			;COMPUTE OFFSET.
	TXA
	PHA			;PRSERVE AWHILE.
	CLC
	LDX	#0
	;SBCDY	DSCPNT		;GET LENGTH OF WHAT'S LEFT.
	SBC	(DSCPNT),Y
	;
	BCS	RLEFT2		;GIVE NULL STRING.
	EOR	#255		;IN SUB C WAS 0 SO JUST COMPLEMENT.
	CMP	FACLO		;GREATER THAN WHAT'S DESIRED?
	BCC	RLEFT3		;NO, COPY THAT MUCH.
	LDA	FACLO		;GET LENGTH OF WHAT'S DESIRED.
	BCS	RLEFT3		;COPY IT.

;
; USED BY RIGHT$, LEFT$, MID$ FOR PARAMETER CHECKING AND SETUP.
;
PREAM:	JSR	CHKCLS		;PARAM LIST SHOULD END.
	PLA			;GET THE RETURN ADDRESS INTO
	TAY			;[JMPER+1,Y]
	PLA
	STA	JMPER+1
	PLA			;GET RID OF FINGO'S JSR RET ADDR.
	PLA
	PLA			;GET LENGTH.
	TAX
	;PULWD	DSCPNT
	PLA
	STA	DSCPNT
	PLA
	STA	DSCPNT+1
	;
	LDA	JMPER+1		;PUT RETURN ADDRESS BACK ON
	PHA
	TYA
	PHA
	LDY	#0
	TXA
	RTS
;
; THE FUNCTION LEN($) RETURNS THE LENGTH OF THE STRING
; PASSED AS AN ARGUMENT.
;
LEN:	JSR	LEN1
	JMP	SNGFLT
LEN1:	JSR	FRESTR		;FREE UP STRING.
	LDX	#0
	STX	VALTYP		;FORCE NUMERIC.
	TAY			;SET CODES ON LENGTH.
	RTS			;DONE.
;
; THE FOLLOWING IS THE ASC($) FUNCTION. IT RETURNS
; AN INTEGER WHICH IS THE DECIMAL ASCII EQUIVALENT.
;
ASC:	JSR	LEN1
	BEQ	GOFUC		;NULL STRING, BAD ARG.
	LDY	#0
	;LDADY	INDEX1		;GET CHARACTER.
	LDA	(INDEX1),Y
	;
	TAY
	JMP	SNGFLT
GOFUC:	JMP	FCERR		;YES.

GTBYTC: JSR	CHRGET
GETBYT: JSR	FRMNUM		;READ FORMULA INTO FAC.
CONINT: JSR	POSINT		;CONVERT THE FAC TO A SINGLE BYTE INT.
	LDX	FACMO
	BNE	GOFUC		;RESULT MUST BE .LE. 255.
	LDX	FACLO
CHRGO2: JMP	CHRGOT		;SET CONDITION CODES ON TERMINATOR.
;
; THE "VAL" FUNCTION TAKES A STRING AND TURNS IT INTO
; A NUMBER BY INTERPRETING THE ASCII DIGITS ETCQ
; EXCEPT FOR THE PROBLEM THAT A TERMINATOR MUST BE SUPPLIED
; BY REPLACING THE CHARACTER BEYOND THE STRING, VAL IS MERELY
; A CALL TO FLOATING POINT INPUT ("FIN").
;
VAL:	JSR	LEN1		;DO SETUP. SET RESULT=NUMERIC.
	;JEQ	ZEROFC		;ZERO THE FAC ON A NULL STRING
	BNE	$+5
	JMP	ZEROFC
	;
	;LDXY	TXTPTR
	LDX	TXTPTR
	LDY	TXTPTR+1
	;STXY	STRNG2		;SAVE FOR LATER.
	STX	STRNG2
	STY	STRNG2+1
	LDX	INDEX1
	STX	TXTPTR
	CLC
	ADC	INDEX1
	STA	INDEX2
	LDX	INDEX1+1
	STX	TXTPTR+1
	BCC	VAL2		;NO CARRY, NO INC.
	INX
VAL2:	STX	INDEX2+1
	LDY	#0
	;LDADY	INDEX2		;PRESERVE CHARACTER.
	LDA	(INDEX2),Y
	;
	PHA
	LDA	#0		;SET A TERMINATOR.
	;STADY	INDEX2
	STA	(INDEX2),Y
	;
	JSR	CHRGOT		;GET CHARACTER PNT'D TO AND SET FLAGS.
	JSR	FIN
	PLA			;GET PRES'D CHARACTER.
	LDY	#0
	;STADY	INDEX2		;STUFF IT BACK.
	STA	(INDEX2),Y
	;
ST2TXT: ;LDXY	STRNG2
	LDX	STRNG2
	LDY	STRNG2+1
	;STXY	TXTPTR
	STX	TXTPTR
	STY	TXTPTR+1
VALRTS: RTS			;ALL DONE WITH STRINGS.

GETNUM: JSR	FRMNUM		;GET ADDRESS.
	JSR	GETADR		;GET THAT LOCATION.
COMBYT: JSR	CHKCOM		;CHECK FOR A COMMA.
	JMP	GETBYT		;GET SOMETHING TO STORE AND RETURN.
GETADR: LDA	FACSGN		;EXAMINE SIGN.
	BMI	GOFUC		;FUNCTION CALL ERROR.
	LDA	FACEXP		;EXAMINE EXPONENT.
	CMP	#145
	BCS	GOFUC		;FUNCTION CALL ERROR.
	JSR	QINT		;INTEGERIZE IT.
	;LDWD	FACMO
	LDA	FACMO
	LDY	FACMO+1
	STY	POKER
	STA	POKER+1
	RTS			;IT'S DONE !.

PEEK:	;PSHWD	POKER
	LDA	POKER+1
	PHA
	LDA	POKER
	PHA
	;
	JSR	GETADR
	LDY	#0
GETCON: ;LDADY	POKER		;GET THAT BYTE.
	LDA	(POKER),Y
	;
	TAY
DOSGFL: ;PULWD	POKER
	PLA
	STA	POKER
	PLA
	STA	POKER+1
	;
	JMP	SNGFLT		;FLOAT IT.

POKE:	JSR	GETNUM
	TXA
	LDY	#0
	;STADY	POKER		;STORE VALUE AWAY.
	STA	(POKER),Y
	;
	RTS			;SCANNED  EVERYTHING.

; THE WAIT LOCATION,MASK1,MASK2 STATEMENT WAITS UNTIL THE CONTENTS
; OF LOCATION IS NONZERO WHEN XORED WITH MASK2
; AND THEN ANDED WITH MASK1. IF MASK2 IS NOT PRESENT, IT
; IS ASSUMED TO BE ZERO.

FNWAIT: JSR	GETNUM
	STX	ANDMSK
	LDX	#0
	JSR	CHRGOT
	BEQ	ZSTORDO
	JSR	COMBYT		;GET MASK2.
STORDO: STX	EORMSK
	LDY	#0
WAITER: ;LDADY	POKER
	LDA	(POKER),Y
	;
	EOR	EORMSK
	AND	ANDMSK
	BEQ	WAITER
ZERRTS: RTS			;GOT A NONZERO.

;RADIX	8			;!!!! ALERT !!!!
				;THROUGHOUT THE MATH PACKAGE.
FADDH:	;LDWDI	FHALF		;ENTRY TO ADD 1/2.
	LDA	#FHALF
	LDY	#FHALF>>8
	;
	JMP	FADD		;UNPACK AND GO ADD IT.
FSUB:	JSR	CONUPK		;UNPACK ARGUMENT INTO ARG.
FSUBT:	LDA	FACSGN
	EOR	#0377		;COMPLEMENT IT.
	STA	FACSGN
	EOR	ARGSGN		;COMPLEMENT ARISGN.
	STA	ARISGN
	LDA	FACEXP		;SET CODES ON FACEXP.
	JMP	FADDT		;[Y]=ARGEXP..

ZSTORDO	EQU	STORDO

FADD5:	JSR	SHIFTR		;DO A LONG SHIFT.
	BCC	FADD4		;CONTINUE WITH ADDITION.
FADD:	JSR	CONUPK
FADDT:	;JEQ	MOVFA		;IF FAC=0, RESULT IS IN ARG.
	BNE	$+5
	JMP	MOVFA
	;
	LDX	FACOV
	STX	OLDOV
	LDX	#ARGEXP		;DEFAULT IS SHIFT ARGUMENT.
	LDA	ARGEXP		;IF ARG=0, FAC IS RESULT.
FADDC:	TAY			;ALSO COPY ACCA INTO ACCY.
	BEQ	ZERRTS		;RETURN.
	SEC
	SBC	FACEXP
	BEQ	FADD4		;NO SHIFTING.
	BCC	FADDA		;BR IF ARGEXP.LT.FACEXP.
	STY	FACEXP		;RESULTING EXPONENT.
	LDY	ARGSGN		;SINCE ARG IS BIGGER, IT'S
	STY	FACSGN		;SIGN IS SIGN OF RESULT.
	EOR	#0377		;SHIFT A NEGATIVE NUMBER OF PLACES.
	ADC	#0		;COMPLETE NEGATION. W/ C=1.
	LDY	#0		;ZERO OLDOV.
	STY	OLDOV
	LDX	#FAC		;SHIFT THE FAC INSTEAD.
	BNE	FADD1
FADDA:	LDY	#0
	STY	FACOV
FADD1:	CMP	#256-7		;FOR SPEED AND NECESSITY.  GETS
				;MOST LIKELY CASE TO SHIFTR FASTEST
				;AND ALLOWS SHIFTING OF NEG NUMS
				;BY "QINT".
	BMI	FADD5		;SHIFT BIG.
	TAY
	LDA	FACOV		;SET FACOV.
	LSR	1,X		;GETS 0 IN MOST SIG BIT.
	JSR	ROLSHF		;DO THE ROLLING.
FADD4:	BIT	ARISGN		;GET RESULTING SIGN.
	BPL	FADD2		;IF POSITIVE, ADD.
				;CARRY IS CLEAR.
FADD3:	LDY	#FACEXP
	CPX	#ARGEXP		;FAC IS BIGGER.
	BEQ	SUBIT
	LDY	#ARGEXP		;ARG IS BIGGER.
SUBIT:	SEC
	EOR	#0377
	ADC	OLDOV
	STA	FACOV
	LDA	3+ADDPRC,Y
	SBC	3+ADDPRC,X
	STA	FACLO
	LDA	2+ADDPRC,Y
	SBC	2+ADDPRC,X
	STA	FACMO
	LDA	2,Y
	SBC	2,X
	STA	FACMOH
	LDA	1,Y
	SBC	1,X
	STA	FACHO
FADFLT: BCS	NORMAL		;HERE IF SIGNS DIFFER. IF CARRY,
				;FAC IS SET OK.
	JSR	NEGFAC		;NEGATE [FAC].
NORMAL: LDY	#0
	TYA
	CLC
NORM3:	LDX	FACHO
	BNE	NORM1
	LDX	FACHO+1		;SHIFT 8 BITS AT A TIME FOR SPEED.
	STX	FACHO
	LDX	FACMOH+1
	STX	FACMOH
	LDX	FACMO+1
	STX	FACMO
	LDX	FACOV
	STX	FACLO
	STY	FACOV
	ADC	#010
	CMP	#010*ADDPRC+030
	BNE	NORM3
ZEROFC: LDA	#0		;NOT NEED BY NORMAL BUT BY OTHERS.
ZEROF1: STA	FACEXP		;NUMBER MUST BE ZERO.
ZEROML: STA	FACSGN		;MAKE SIGN POSITIVE.
	RTS			;ALL DONE.
FADD2:	ADC	OLDOV
	STA	FACOV
	LDA	FACLO
	ADC	ARGLO
	STA	FACLO
	LDA	FACMO
	ADC	ARGMO
	STA	FACMO
	LDA	FACMOH
	ADC	ARGMOH
	STA	FACMOH
	LDA	FACHO
	ADC	ARGHO
	STA	FACHO
	JMP	SQUEEZ		;GO ROUND IF SIGNS SAME.

NORM2:	ADC	#1		;DECREMENT SHIFT COUNT.
	ASL	FACOV		;SHIFT ALL LEFT ONE BIT.
	ROL	FACLO
	ROL	FACMO
	ROL	FACMOH
	ROL	FACHO
NORM1:	BPL	NORM2		;IF MSB=0 SHIFT AGAIN.
	SEC
	SBC	FACEXP
	BCS	ZEROFC
	EOR	#0377
	ADC	#1		;COMPLEMENT.
	STA	FACEXP
SQUEEZ: BCC	RNDRTS		;BITS TO SHIFT?
RNDSHF: INC	FACEXP
	BEQ	OVERR
	ROR	FACHO
	ROR	FACMOH
	ROR	FACMO
	ROR	FACLO
	ROR	FACOV
RNDRTS: RTS			;ALL DONE ADDING.

NEGFAC: ;COM	FACSGN		;COMPLEMENT FAC	 ENTIRELY.
	LDA	FACSGN
	EOR	#255
	STA	FACSGN
	;
NEGFCH: ;COM	FACHO		;COMPLEMENT JUST THE NUMBER.
	LDA	FACHO
	EOR	#255
	STA	FACHO
	;
	;COM	FACMOH
	LDA	FACMOH
	EOR	#255
	STA	FACMOH
	;
	;COM	FACMO
	LDA	FACMO
	EOR	#255
	STA	FACMO
	;
	;COM	FACLO
	LDA	FACLO
	EOR	#255
	STA	FACLO
	;
	;COM	FACOV
	LDA	FACOV
	EOR	#255
	STA	FACOV
	;
	INC	FACOV
	BNE	INCFRT
INCFAC: INC	FACLO
	BNE	INCFRT
	INC	FACMO
	BNE	INCFRT		;IF NO CARRY, RETURN.
	INC	FACMOH
	BNE	INCFRT
	INC	FACHO		;CARRY INCREMENT.
INCFRT: RTS

OVERR:	LDX	#ERROV
	JMP	ERROR		;TELL USER.
;
; "SHIFTR" SHIFTS [X+1:X+3] [-ACCA]  BITS RIGHT.
; SHIFTS BYTES TO START WITH IF POSSIBLE.
;
MULSHF: LDX	#RESHO-1	;ENTRY POINT FOR MULTIPLIER.
SHFTR2: LDY	3+ADDPRC,X	;SHIFT BYTES FIRST.
	STY	FACOV
	LDY	3,X
	STY	4,X
	LDY	2,X		;GET MO.
	STY	3,X		;STORE LO.
	LDY	1,X		;GET HO.
	STY	2,X		;STORE MO.
	LDY	BITS
	STY	1,X		;STORE HO.
SHIFTR: ADC	#010
	BMI	SHFTR2
	BEQ	SHFTR2
	SBC	#010		;C CAN BE EITHER 1,0 AND IT WORKS.
	TAY
	LDA	FACOV
	BCS	SHFTRT		;EQUIV TO BEQ HERE.
SHFTR3: ASL	1,X
	BCC	SHFTR4
	INC	1,X
SHFTR4: ROR	1,X
	ROR	1,X		;YES, TWO OF THEM.
ROLSHF:
	ROR	2,X
	ROR	3,X
	ROR	4,X		;ONE MO TIME.

	ROR	A		;ROTATE ARGUMENT 1 BIT RIGHT.
SHFTR7: INY
	BNE	SHFTR3		;$$$ ( MOST EXPENSIVE ! )
SHFTRT: CLC			;CLEAR OUTPUT OF FACOV.
	RTS
;
; CALCULATION IS BY:
; LN(F*2^N)=(N+LOG2(F))*LN(2)
; AN APPROXIMATION POLYNOMIAL IS USED TO CALCULATE LOG2(F).
;  CONSTANTS USED BY LOG:
FONE:	BYTE	0201	; 1.0
	BYTE	0000
	BYTE	0000
	BYTE	0000
	BYTE	0

LOGCN2: BYTE	3	;DEGREE-1
	BYTE	0177	;.43425594188
	BYTE	0136
	BYTE	0126
	BYTE	0313
	BYTE	0171
	BYTE	0200	; .57658454134
	BYTE	0023
	BYTE	0233
	BYTE	0013
	BYTE	0144
	BYTE	0200	; .96180075921
	BYTE	0166
	BYTE	0070
	BYTE	0223
	BYTE	0026
	BYTE	0202	; 2.8853900728
	BYTE	0070
	BYTE	0252
	BYTE	0073
	BYTE	0040
SQRHLF: BYTE	0200	; SQR(0.5)
	BYTE	0065
	BYTE	0004
	BYTE	0363
	BYTE	0064
SQRTWO: BYTE	0201	; SQR(2.0)
	BYTE	0065
	BYTE	0004
	BYTE	0363
	BYTE	0064
NEGHLF: BYTE	0200	; -1/2
	BYTE	0200
	BYTE	0000
	BYTE	0000
	BYTE	0
LOG2:	BYTE	0200	; LN(2)
	BYTE	0061
	BYTE	0162
	BYTE	0027
	BYTE	0370

LOG:	JSR	SIGN		;IS IT POSITIVE?
	BEQ	LOGERR
	BPL	LOG1
LOGERR: JMP	FCERR		;CAN'T TOLERATE NEG OR ZERO.
LOG1:	LDA	FACEXP		;GET EXPONENT INTO ACCA.
	SBC	#0177		;REMOVE BIAS. (CARRY IS OFF)
	PHA			;SAVE AWHILE.
	LDA	#0200
	STA	FACEXP		;RESULT IS FAC IN RANGE [0.5,1].
	;LDWDI	SQRHLF		;GET POINTER TO SQR(0.5).
	LDA	#SQRHLF
	LDY	#SQRHLF>>8
	;

; CALCULATE (F-SQR(.5))/(F+SQR(.5))

	JSR	FADD		;ADD TO FAC.
	;LDWDI	SQRTWO		;GET SQR(2.).
	LDA	#SQRTWO
	LDY	#SQRTWO>>8
	;
	JSR	FDIV
	;LDWDI	FONE
	LDA	#FONE
	LDY	#FONE>>8
	;
	JSR	FSUB
	;LDWDI	LOGCN2
	LDA	#LOGCN2
	LDY	#LOGCN2>>8
	;
	JSR	POLYX		;EVALUATE APPROXIMATION POLYNOMIAL.
	;LDWDI	NEGHLF		;ADD IN LAST CONSTANT.
	LDA	#NEGHLF
	LDY	#NEGHLF>>8
	;
	JSR	FADD
	PLA			;GET EXPONENT BACK.
	JSR	FINLOG		;ADD IT IN.
MULLN2: ;LDWDI	LOG2		;MULTIPLY RESULT BY LOG(2.0).
	LDA	#LOG2
	LDY	#LOG2>>8
	;
;	JMP	FMULT		;MULTIPLY TOGETHER.

	;MULTIPLICATION		FAC:=ARG*FAC.
FMULT:	JSR	CONUPK		;UNPACK THE CONSTANT INTO ARG FOR USE.
FMULTT: ;JEQ	MULTRT		;IF FAC=0, RETURN. FAC IS SET.
	BNE	$+5
	JMP	MULTRT
	;
	JSR	MULDIV		;FIX UP THE EXPONENTS.
	LDA	#0		;TO CLEAR RESULT.
	STA	RESHO
	STA	RESMOH
	STA	RESMO
	STA	RESLO
	LDA	FACOV
	JSR	MLTPLY
	LDA	FACLO		;MLTPLY ARG BY FACLO.
	JSR	MLTPLY
	LDA	FACMO		;MLTPLY ARG BY FACMO.
	JSR	MLTPLY
	LDA	FACMOH
	JSR	MLTPLY
	LDA	FACHO		;MLTPLY ARG BY FACHO.
	JSR	MLTPL1
	JMP	MOVFR		;MOVE RESULT INTO FAC,
				;NORMALIZE RESULT, AND RETURN.
MLTPLY: ;JEQ	MULSHF		;SHIFT RESULT RIGHT 1 BYTE.
	BNE	$+5
	JMP	MULSHF
	;
MLTPL1: LSR	A
	ORA	#0200
MLTPL2: TAY
	BCC	MLTPL3		;IT MULT BIT=0, JUST SHIFT.
	CLC
	LDA	RESLO
	ADC	ARGLO
	STA	RESLO
	LDA	RESMO
	ADC	ARGMO
	STA	RESMO
	LDA	RESMOH
	ADC	ARGMOH
	STA	RESMOH
	LDA	RESHO
	ADC	ARGHO
	STA	RESHO
MLTPL3: ROR	RESHO
	ROR	RESMOH
	ROR	RESMO
	ROR	RESLO
	ROR	FACOV		;SAVE FOR ROUNDING.
	TYA
	LSR	A		;CLEAR MSB SO WE GET A CLOSER TO 0.
	BNE	MLTPL2		;SLOW AS A TURTLE !
MULTRT: RTS

	;ROUTINE TO UNPACK MEMORY INTO ARG.
CONUPK: ;STWD	INDEX1
	STA	INDEX1
	STY	INDEX1+1
	;
	LDY	#3+ADDPRC
	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	STA	ARGLO
	DEY
	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	STA	ARGMO
	DEY
	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	STA	ARGMOH
	DEY
	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	STA	ARGSGN
	EOR	FACSGN
	STA	ARISGN
	LDA	ARGSGN
	ORA	#0200
	STA	ARGHO
	DEY
	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	STA	ARGEXP
	LDA	FACEXP		;SET CODES OF FACEXP.
	RTS

	;CHECK SPECIAL CASES AND ADD EXPONENTS FOR FMULT, FDIV.
MULDIV: LDA	ARGEXP		;EXP OF ARG=0?
MLDEXP: BEQ	ZEREMV		;SO WE GET ZERO EXPONENT.
	CLC
	ADC	FACEXP		;RESULT IS IN ACCA.
	BCC	TRYOFF		;FIND [C] XOR [N].
	BMI	GOOVER		;OVERFLOW IF BITS MATCH.
	CLC
	BYTE	SKIP2
TRYOFF: BPL	ZEREMV		;UNDERFLOW.
	ADC	#0200		;ADD BIAS.
	STA	FACEXP
	;JEQ	ZEROML		;ZERO THE REST OF IT.
	BNE	$+5
	JMP	ZEROML
	;
	LDA	ARISGN
	STA	FACSGN		;ARISGN IS RESULT'S SIGN.
	RTS			;DONE.
MLDVEX: LDA	FACSGN		;GET SIGN.
	EOR	#0377		;COMPLEMENT IT.
	BMI	GOOVER
ZEREMV: PLA			;GET ADDR OFF STACK.
	PLA	
	JMP	ZEROFC		;UNDERFLOW.
GOOVER: JMP	OVERR		;OVERFLOW.

	;MULTIPLY FAC BY 10.
MUL10:	JSR	MOVAF		;COPY FAC INTO ARG.
	TAX
	BEQ	MUL10R		;IF [FAC]=0, GOT ANSWER.
	CLC
	ADC	#2		;AUGMENT EXP BY 2.
	BCS	GOOVER		;OVERFLOW.
FINML6: LDX	#0
	STX	ARISGN		;SIGNS ARE SAME.
	JSR	FADDC		;ADD TOGETHER.
	INC	FACEXP		;MULTIPLY BY TWO.
	BEQ	GOOVER		;OVERFLOW.
MUL10R: RTS

	; DIVIDE FAC BY 10.
TENZC:	BYTE	0204
	BYTE	0040
	BYTE	0000
	BYTE	0000
	BYTE	0
DIV10:	JSR	MOVAF		;MOVE FAC TO ARG.
	;LDWDI	TENZC		;POINT TO CONSTANT OF 10.0
	LDA	#TENZC
	LDY	#TENZC>>8
	;
	LDX	#0		;SIGNS ARE BOTH POSITIVE.
FDIVF:	STX	ARISGN
	JSR	MOVFM		;PUT IT INTO FAC.
	JMP	FDIVT		;SKIP OVER NEXT TWO BYTES.
FDIV:	JSR	CONUPK		;UNPACK CONSTANT.
FDIVT:	BEQ	DV0ERR		;CAN'T DIVIDE BY ZERO !
				;(NOT ENOUGH ROOM TO STORE RESULT.)
	JSR	ROUND		;TAKE FACOV INTO ACCT IN FAC.
	LDA	#0		;NEGATE FACEXP.
	SEC
	SBC	FACEXP
	STA	FACEXP
	JSR	MULDIV		;FIX UP EXPONENTS.
	INC	FACEXP		;SCALE IT RIGHT.
	BEQ	GOOVER		;OVERFLOW.
	LDX	#256-3-ADDPRC	;SETUP PROCEDURE.
	LDA	#1
DIVIDE:				;THIS IS THE BEST CODE IN THE WHOLE PILE.
	LDY	ARGHO		;SEE WHAT RELATION HOLDS.
	CPY	FACHO
	BNE	SAVQUO		;[C]=0,1. N(C=0)=0.
	LDY	ARGMOH
	CPY	FACMOH
	BNE	SAVQUO
	LDY	ARGMO
	CPY	FACMO
	BNE	SAVQUO
	LDY	ARGLO
	CPY	FACLO
SAVQUO: PHP
	ROL	A		;SAVE RESULT.
	BCC	QSHFT		;IF NOT DONE, CONTINUE.
	INX
	STA	RESLO,X
	BEQ	LD100
	BPL	DIVNRM		;NOTE THIS REQ 1 MO RAM THEN NECESS.
	LDA	#1
QSHFT:	PLP			;RETURN CONDITION CODES.
	BCS	DIVSUB		;FAC .LE. ARG.
SHFARG: ASL	ARGLO		;SHIFT ARG ONE PLACE LEFT.
	ROL	ARGMO
	ROL	ARGMOH
	ROL	ARGHO
	BCS	SAVQUO		;SAVE A RESULT OF ONE FOR THIS POSITION
				;AND DIVIDE.
	BMI	DIVIDE		;IF MSB ON, GO DECIDE WHETHER TO SUB.
	BPL	SAVQUO
DIVSUB: TAY			;NOTICE C MUST BE ON HERE.
	LDA	ARGLO
	SBC	FACLO
	STA	ARGLO
	LDA	ARGMO
	SBC	FACMO
	STA	ARGMO
	LDA	ARGMOH
	SBC	FACMOH
	STA	ARGMOH
	LDA	ARGHO
	SBC	FACHO
	STA	ARGHO
	TYA
	JMP	SHFARG
LD100:	LDA	#0100		;ONLY WANT TWO MORE BITS.
	BNE	QSHFT		;ALWAYS BRANCHES.
DIVNRM: ;REPEAT	6,<ASL	A>	;GET LAST TWO BITS INTO MSB AND B6.
	ASL	A
	ASL	A
	ASL	A
	ASL	A
	ASL	A
	ASL	A
	;
	STA	FACOV
	PLP			;TO GET GARBAGE OFF STACK.
	JMP	MOVFR		;MOVE RESULT INTO FAC, THEN
				;NORMALIZE RESULT AND RETURN.
DV0ERR: LDX	#ERRDV0
	JMP	ERROR

	;MOVE RESULT TO FAC.
MOVFR:	LDA	RESHO
	STA	FACHO
	LDA	RESMOH
	STA	FACMOH
	LDA	RESMO
	STA	FACMO
	LDA	RESLO		;MOVE LO AND SGN.
	STA	FACLO
	JMP	NORMAL		;ALL DONE.

	;MOVE MEMORY INTO FAC (UNPACKED).
MOVFM:	;STWD	INDEX1
	STA	INDEX1
	STY	INDEX1+1
	;
	LDY	#3+ADDPRC
	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	STA	FACLO
	DEY
	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	STA	FACMO
	DEY
	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	STA	FACMOH
	DEY
	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	STA	FACSGN
	ORA	#0200
	STA	FACHO
	DEY
	;LDADY	INDEX1
	LDA	(INDEX1),Y
	;
	STA	FACEXP		;LEAVE SWITCHES SET ON EXP.
	STY	FACOV
	RTS

	;MOVE NUMBER FROM FAC TO MEMORY.
MOV2F:	LDX	#TEMPF2
	BYTE	SKIP2
MOV1F:	LDX	#TEMPF1
MOVML:	LDY	#0
	BEQ	MOVMF		;ALWAYS BRANCHES.
MOVVF:	;LDXY	FORPNT
	LDX	FORPNT
	LDY	FORPNT+1
	;
MOVMF:	JSR	ROUND
	;STXY	INDEX1
	STX	INDEX1
	STY	INDEX1+1
	;
	LDY	#3+ADDPRC
	LDA	FACLO
	;STADY	INDEX
	STA	(INDEX),Y
	;
	DEY
	LDA	FACMO
	;STADY	INDEX
	STA	(INDEX),Y
	;
	DEY
	LDA	FACMOH
	;STADY	INDEX
	STA	(INDEX),Y
	;
	DEY
	LDA	FACSGN		;INCLUDE SIGN IN HO.
	ORA	#0177
	AND	FACHO
	;STADY	INDEX
	STA	(INDEX),Y
	;
	DEY
	LDA	FACEXP
	;STADY	INDEX
	STA	(INDEX),Y
	;
	STY	FACOV		;ZERO IT SINCE ROUNDED.
	RTS			;[Y]=0.

	;MOVE ARG INTO FAC.
MOVFA:	LDA	ARGSGN
MOVFA1: STA	FACSGN
	LDX	#4+ADDPRC
MOVFAL: LDA	ARGEXP-1,X
	STA	FACEXP-1,X
	DEX
	BNE	MOVFAL
	STX	FACOV
	RTS

	;MOVE FAC INTO ARG.
MOVAF:	JSR	ROUND
MOVEF:	LDX	#5+ADDPRC
MOVAFL: LDA	FACEXP-1,X
	STA	ARGEXP-1,X
	DEX
	BNE	MOVAFL
	STX	FACOV		;ZERO IT SINCE ROUNDED.
MOVRTS: RTS

ROUND:	LDA	FACEXP		;ZERO?
	BEQ	MOVRTS		;YES. DONE ROUNDING.
	ASL	FACOV		;ROUND?
	BCC	MOVRTS		;NO. MSB OFF.
INCRND: JSR	INCFAC		;YES, ADD ONE TO LSB(FAC).
	BNE	MOVRTS		;NO CARRY MEANS DONE.
	JMP	RNDSHF		;SQUEEZ MSB IN AND RTS.
				;NOTE [C]=1 SINCE INCFAC DOESNT TOUCH C.

	;PUT SIGN OF FAC IN ACCA.
SIGN:	LDA	FACEXP
	BEQ	SIGNRT		;IF NUMBER IS ZERO, SO IS RESULT.
FCSIGN: LDA	FACSGN
FCOMPS: ROL	A
	LDA	#0377		;ASSUME NEGATIVE.
	BCS	SIGNRT
	LDA	#1		;GET +1.
SIGNRT: RTS

	;SGN FUNCTION.
SGN:	JSR	SIGN

	;FLOAT THE SIGNED INTEGER IN ACCA.
FLOAT:	STA	FACHO		;PUT [ACCA] IN HIGH ORDER.
	LDA	#0
	STA	FACHO+1
	LDX	#0210		;GET THE EXPONENT.

	;FLOAT THE SIGNED NUMBER IN FAC.
FLOATS: LDA	FACHO
	EOR	#0377
	ROL	A		;GET COMP OF SIGN IN CARRY.
FLOATC: LDA	#0		;ZERO [ACCA] BUT NOT CARRY.
	STA	FACLO
	STA	FACMO
FLOATB: STX	FACEXP
	STA	FACOV
	STA	FACSGN
	JMP	FADFLT

	;ABSOLUTE VALUE OF FAC.
ABS:	LSR	FACSGN
	RTS

	;A=1 IF ARG .LT. FAC.
	;A=0 IF ARG=FAC.
	;A=-1 IF ARG .GT. FAC.
FCOMP:	STA	INDEX2
FCOMPN: STY	INDEX2+1
	LDY	#0
	;LDADY	INDEX2		;HAS ARGEXP.
	LDA	(INDEX2),Y
	;
	INY			;BUMP PNTR UP.
	TAX			;SAVE A IN X AND RESET CODES.
	BEQ	SIGN
	;LDADY	INDEX2
	LDA	(INDEX2),Y
	;
	EOR	FACSGN		;SIGNS THE SAME.
	BMI	FCSIGN		;SIGNS DIFFER SO RESULT IS
				;SIGN OF FAC AGAIN.
FOUTCP: CPX	FACEXP
	BNE	FCOMPC
	;LDADY	INDEX2
	LDA	(INDEX2),Y
	;
	ORA	#0200
	CMP	FACHO
	BNE	FCOMPC
	INY
	;LDADY	INDEX2
	LDA	(INDEX2),Y
	;
	CMP	FACMOH
	BNE	FCOMPC
	INY
	;LDADY	INDEX2
	LDA	(INDEX2),Y
	;
	CMP	FACMO
	BNE	FCOMPC
	INY
	LDA	#0177
	CMP	FACOV
	;LDADY	INDEX2
	LDA	(INDEX2),Y
	;
	SBC	FACLO		;GET ZERO IF EQUAL.
	BEQ	QINTRT
FCOMPC: LDA	FACSGN
	BCC	FCOMPD
	EOR	#0377
FCOMPD: JMP	FCOMPS		;A PART OF SIGN SETS ACCA UP.

	;QUICK GREATEST INTEGER FUNCTION.
	;LEAVES INT(FAC) IN FACHO&MO&LO SIGNED.
	;ASSUMES FAC .LT. 2^23 = 8388608
QINT:	LDA	FACEXP
	BEQ	CLRFAC		;IF ZERO, GOT IT.
	SEC
	SBC	#8*ADDPRC+0230	;GET NUMBER OF PLACES TO SHIFT.
	BIT	FACSGN
	BPL	QISHFT
	TAX
	LDA	#0377
	STA	BITS		;PUT 377 IN WHEN SHFTR SHIFTS BYTES.
	JSR	NEGFCH		;TRULY NEGATE QUANTITY IN FAC.
	TXA
QISHFT: LDX	#FAC
	CMP	#256-7
	BPL	QINT1		;IF NUMBER OF PLACES .GE. 7
				;SHIFT 1 PLACE AT A TIME.
	JSR	SHIFTR		;START SHIFTING BYTES, THEN BITS.
	STY	BITS		;ZERO BITS SINCE ADDER WANTS ZERO.
QINTRT: RTS
QINT1:	TAY			;PUT COUNT IN COUNTER.
	LDA	FACSGN
	AND	#0200		;GET SIGN BIT.
	LSR	FACHO		;SAVE FIRST SHIFTED BYTE.
	ORA	FACHO
	STA	FACHO
	JSR	ROLSHF		;SHIFT THE REST.
	STY	BITS		;ZERO [BITS].
	RTS

	;GREATEST INTEGER FUNCTION.
INT:	LDA	FACEXP
	CMP	#8*ADDPRC+0230
	BCS	INTRTS		;FORGET IT.
	JSR	QINT
	STY	FACOV		;CLR OVERFLOW BYTE.
	LDA	FACSGN
	STY	FACSGN		;MAKE FAC LOOK POSITIVE.
	EOR	#0200		;GET COMPLEMENT OF SIGN IN CARRY.
	ROL	A
	LDA	#8*ADDPRC+0230
	STA	FACEXP
	LDA	FACLO
	STA	INTEGR
	JMP	FADFLT
CLRFAC: STA	FACHO		;MAKE IT REALLY ZERO.
	STA	FACMOH
	STA	FACMO
	STA	FACLO
	TAY
INTRTS: RTS
	;NUMBER INPUT IS LEFT IN FAC.
	;AT ENTRY [TXTPTR] POINTS TO THE FIRST CHARACTER IN A TEXT BUFFER.
	;THE FIRST CHARACTER IS ALSO IN ACCA. FIN PACKS THE DIGITS
	;INTO THE FAC AS AN INTEGER AND KEEPS TRACK OF WHERE THE
	;DECIMAL POINT IS. [DPTFLG] TELL WHETHER A DP HAS BEEN
	;SEEN. [DECCNT] IS THE NUMBER OF DIGITS AFTER THE DP.
	;AT THE END [DECCNT] AND THE EXPONENT ARE USED TO
	;DETERMINE HOW MANY TIMES TO MULTIPLY OR DIVIDE BY TEN
	;TO GET THE CORRECT NUMBER.
FIN:	LDY	#0		;ZERO FACSGN&SGNFLG.
	LDX	#011+ADDPRC	;ZERO EXP AND HO (AND MOH).
FINZLP: STY	DECCNT,X	;ZERO MO AND LO.
	DEX			;ZERO TENEXP AND EXPSGN
	BPL	FINZLP		;ZERO DECCNT, DPTFLG.
	BCC	FINDGQ		;FLAGS STILL SET FROM CHRGET.
	CMP	#"-"		;A NEGATIVE SIGN?
	BNE	QPLUS		;NO, TRY PLUS SIGN.
	STX	SGNFLG		;IT'S NEGATIVE. (X=377).
	BEQ	FINC		;ALWAYS BRANCHES.
QPLUS:	CMP	#"+"		;PLUS SIGN?
	BNE	FIN1		;YES, SKIP IT.
FINC:	JSR	CHRGET
FINDGQ: BCC	FINDIG
FIN1:	CMP	#"."		;THE DP?
	BEQ	FINDP		;NO KIDDING.
	CMP	#"E"		;EXPONENT FOLLOWS.
	BNE	FINE		;NO.
	;HERE TO CHECK FOR SIGN OF EXP.
	JSR	CHRGET		;YES. GET ANOTHER.
	BCC	FNEDG1		;IT IS A DIGIT. (EASIER THAN
				;BACKING UP POINTER.)
	CMP	#MINUTK		;MINUS?
	BEQ	FINEC1		;NEGATE.
	CMP	#"-"		;MINUS SIGN?
	BEQ	FINEC1
	CMP	#PLUSTK		;PLUS?
	BEQ	FINEC
	CMP	#"+"		;PLUS SIGN?
	BEQ	FINEC
	BNE	FINEC2
FINEC1: ROR	EXPSGN		;TURN IT ON.
FINEC:	JSR	CHRGET		;GET ANOTHER.
FNEDG1: BCC	FINEDG		;IT IS A DIGIT.
FINEC2: BIT	EXPSGN
	BPL	FINE
	LDA	#0
	SEC
	SBC	TENEXP
	JMP	FINE1
FINDP:	ROR	DPTFLG
	BIT	DPTFLG
	BVC	FINC
FINE:	LDA	TENEXP
FINE1:	SEC
	SBC	DECCNT		;GET NUMBER OF PLACES TO SHIFT.
	STA	TENEXP
	BEQ	FINQNG		;NEGATE?
	BPL	FINMUL		;POSITIVE SO MULTIPLY.
FINDIV: JSR	DIV10
	INC	TENEXP		;DONE?
	BNE	FINDIV		;NO.
	BEQ	FINQNG		;YES.
FINMUL: JSR	MUL10
	DEC	TENEXP		;DONE?
	BNE	FINMUL		;NO
FINQNG: LDA	SGNFLG
	BMI	NEGXQS		;IF POSITIVE, RETURN.
	RTS
NEGXQS: JMP	NEGOP		;OTHERWISE, NEGATE AND RETURN.

FINDIG: PHA
	BIT	DPTFLG
	BPL	FINDG1
	INC	DECCNT
FINDG1: JSR	MUL10
	PLA			;GET IT BACK.
	SEC
	SBC	#"0"
	JSR	FINLOG		;ADD IT IN.
	JMP	FINC

FINLOG: PHA
	JSR	MOVAF		;SAVE FAC FOR LATER.
	PLA
	JSR	FLOAT		;FLOAT THE VALUE IN ACCA.
	LDA	ARGSGN
	EOR	FACSGN
	STA	ARISGN		;RESULTANT SIGN.
	LDX	FACEXP		;SET SIGNS ON THING TO ADD.
	JMP	FADDT		;ADD TOGETHER AND RETURN.

	;HERE PACK IN THE NEXT DIGIT OF THE EXPONENT.
	;MULTIPLY THE OLD EXP BY 10 AND ADD IN THE NEXT
	;DIGIT. NOTE: EXP OVERFLOW IS NOT CHECKED FOR.
FINEDG: LDA	TENEXP		;GET EXP SO FAR.
	CMP	#012		;WILL RESULT BE .GE. 100?
	BCC	MLEX10	
	LDA	#0144		;GET 100.
	BIT	EXPSGN
	BMI	MLEXMI		;IF NEG EXP, NO CHK FOR OVERR.
	JMP	OVERR
MLEX10: ASL	A		;MULT BY 2 TWICE
	ASL	A
	CLC			;POSSIBLE SHIFT OUT OF HIGH.
	ADC	TENEXP		;LIKE MULTIPLYING BY FIVE.
	ASL	A		;AND NOW BY TEN.
	CLC
	LDY	#0
	;ADCDY	TXTPTR
	ADC	(TXTPTR),Y
	;
	SEC
	SBC	#"0"
MLEXMI: STA	TENEXP		;SAVE RESULT.
	JMP	FINEC

NZ0999: BYTE	0233	; 99999999.9499
	BYTE	0076
	BYTE	0274
	BYTE	0037
	BYTE	0375
NZ9999: BYTE	0236	; 999999999.499
	BYTE	0156
	BYTE	0153
	BYTE	0047
	BYTE	0375
NZMIL:	BYTE	0236	; 10^9
	BYTE	0156
	BYTE	0153
	BYTE	0050
	BYTE	0000
	;ENTRY TO LINPRT.
INPRT:	;LDWDI	INTXT
	LDA	#INTXT
	LDY	#INTXT>>8
	;
	JSR	STROU2
	LDA	CURLIN+1
	LDX	CURLIN
LINPRT: ;STWX	FACHO
	STA	FACHO
	STX	FACHO+1
	LDX	#0220		;EXPONENT OF 16.
	SEC			;NUMBER IS POSITIVE.
	JSR	FLOATC
	JSR	FOUT
STROU2: JMP	STROUT		;PRINT AND RETURN.

FOUT:	LDY	#1
FOUTC:	LDA	#" "		;PRINT SPACE IF POSITIVE.
	BIT	FACSGN
	BPL	FOUT1
	LDA	#"-"
FOUT1:	STA	FBUFFR-1,Y	;STORE THE CHARACTER.
	STA	FACSGN		;MAKE FAC POS FOR QINT.
	STY	FBUFPT		;SAVE FOR LATER.
	INY
	LDA	#"0"		;GET ZERO TO TYPE IF FAC=0.
	LDX	FACEXP
	;JEQ	FOUT19
	BNE	$+5
	JMP	FOUT19
	;
	LDA	#0
	CPX	#0200		;IS NUMBER .LT. 1.0 ?
	BEQ	FOUT37		;NO.
	BCS	FOUT7
FOUT37: ;LDWDI	NZMIL		;MULTIPLY BY 10^6.
	LDA	#NZMIL
	LDY	#NZMIL>>8
	;
	JSR	FMULT
	LDA	#256-3*ADDPRC-6
FOUT7:	STA	DECCNT		;SAVE COUNT OR ZERO IT.
FOUT4:	;LDWDI	NZ9999
	LDA	#NZ9999
	LDY	#NZ9999>>8
	;
	JSR	FCOMP		;IS NUMBER .GT. 999999.499 ?
				;OR 999999999.499?
	BEQ	BIGGES
	BPL	FOUT9		;YES. MAKE IT SMALLER.
FOUT3:	;LDWDI	NZ0999
	LDA	#NZ0999
	LDY	#NZ0999>>8
	;
	JSR	FCOMP		;IS NUMBER .GT. 99999.9499 ?
				; OR 99999999.9499?
	BEQ	FOUT38
	BPL	FOUT5		;YES. DONE MULTIPLYING.
FOUT38: JSR	MUL10		;MAKE IT BIGGER.
	DEC	DECCNT
	BNE	FOUT3		;SEE IF THAT DOES IT.
				;THIS ALWAYS GOES.
FOUT9:	JSR	DIV10		;MAKE IT SMALLER.
	INC	DECCNT
	BNE	FOUT4		;SEE IF THAT DOES IT.
				;THIS ALWAYS GOES.

FOUT5:	JSR	FADDH		;ADD A HALF TO ROUND UP.
BIGGES: JSR	QINT
	LDX	#1		;DECIMAL POINT COUNT.
	LDA	DECCNT
	CLC
	ADC	#3*ADDPRC+7	;SHOULD NUMBER BE PRINTED IN E NOTATION?
				;IE, IS NUMBER .LT. .01 ?
	BMI	FOUTPI		;YES.
	CMP	#3*ADDPRC+010	;IS IT .GT. 999999 (999999999)?
	BCS	FOUT6		;YES. USE E NOTATION.
	ADC	#0377		;NUMBER OF PLACES BEFORE DECIMAL POINT.
	TAX			;PUT INTO ACCX.
	LDA	#2		;NO E NOTATION.
FOUTPI: SEC
FOUT6:	SBC	#2		;EFFECTIVELY ADD 5 TO ORIG EXP.
	STA	TENEXP		;THAT IS THE EXPONENT TO PRINT.
	STX	DECCNT		;NUMBER OF DECIMAL PLACES.
	TXA
	BEQ	FOUT39
	BPL	FOUT8		;SOME PLACES BEFORE DEC PNT.
FOUT39: LDY	FBUFPT		;GET POINTER TO OUTPUT.
	LDA	#"."		;PUT IN "."
	INY
	STA	FBUFFR-1,Y
	TXA
	BEQ	FOUT16
	LDA	#"0"		;GET THE ENSUING ZERO.
	INY
	STA	FBUFFR-1,Y
FOUT16: STY	FBUFPT		;SAVE FOR LATER.
FOUT8:	LDY	#0
FOUTIM: LDX	#0200		;FIRST PASS THRU, ACCX HAS MSB SET.
FOUT2:	LDA	FACLO
	CLC
	ADC	FOUTBL+2+ADDPRC,Y
	STA	FACLO
	LDA	FACMO
	ADC	FOUTBL+1+ADDPRC,Y
	STA	FACMO
	LDA	FACMOH
	ADC	FOUTBL+1,Y
	STA	FACMOH
	LDA	FACHO
	ADC	FOUTBL,Y
	STA	FACHO
	INX			;IT WAS DONE YET ANOTHER TIME.
	BCS	FOUT41
	BPL	FOUT2
	BMI	FOUT40
FOUT41: BMI	FOUT2
FOUT40: TXA
	BCC	FOUTYP		;CAN USE ACCA AS IS.
	EOR	#0377		;FIND 11.-[A].
	ADC	#012		;C IS STILL ON TO COMPLETE NEGATION.
				;AND WILL ALWAYS BE ON AFTER.
FOUTYP: ADC	#"0"-1		;GET A CHARACTER TO PRINT.
	;REPEAT	3+ADDPRC,<INY>	;BUMP POINTER UP.
	INY
	INY
	INY
	INY
	;
	STY	FDECPT
	LDY	FBUFPT
	INY			;POINT TO PLACE TO STORE OUTPUT.
	TAX
	AND	#0177		;GET RID OF MSB.
	STA	FBUFFR-1,Y
	DEC	DECCNT
	BNE	STXBUF		;NOT TIME FOR DP YET.
	LDA	#"."
	INY
	STA	FBUFFR-1,Y	;STORE DP.
STXBUF: STY	FBUFPT		;STORE PNTR FOR LATER.
	LDY	FDECPT
FOUTCM: TXA			;COMPLEMENT ACCX
	EOR	#0377		;COMPLEMENT ACCA.
	AND	#0200		;SAVE ONLY MSB.
	TAX
	CPY	#FDCEND-FOUTBL
	BNE	FOUT2		;CONTINUE WITH OUTPUT.
FOULDY: LDY	FBUFPT		;GET BACK OUTPUT PNTR.
FOUT11: LDA	FBUFFR-1,Y	;REMOVE TRAILING ZEROES.
	DEY
	CMP	#"0"
	BEQ	FOUT11
	CMP	#"."
	BEQ	FOUT12		;RUN INTO DP. STOP.
	INY			;SOMETHING ELSE. SAVE IT.
FOUT12: LDA	#"+"
	LDX	TENEXP
	BEQ	FOUT17		;NO EXPONENT TO OUTPUT.
	BPL	FOUT14
	LDA	#0
	SEC
	SBC	TENEXP
	TAX
	LDA	#"-"		;EXPONENT IS NEGATIVE.
FOUT14: STA	FBUFFR-1+2,Y	;STORE SIGN OF EXP
	LDA	#"E"
	STA	FBUFFR-1+1,Y	;STORE THE "E" CHARACTER.
	TXA
	LDX	#"0"-1
	SEC
FOUT15: INX			;MOVE CLOSER TO OUTPUT VALUE.
	SBC	#012		;SUBTRACT 10.
	BCS	FOUT15		;NOT NEGATIVE YET.
	ADC	#"0"+012	;GET SECOND OUTPUT CHARACTER.
	STA	FBUFFR-1+4,Y	;STORE HIGH DIGIT.
	TXA
	STA	FBUFFR-1+3,Y	;STORE	LOW DIGIT.
	LDA	#0		;PUT IN TERMINATOR.
	STA	FBUFFR-1+5,Y
	BEQ	FOUT20		;RETURN. (ALWAYS BRANCHES).
FOUT19: STA	FBUFFR-1,Y	;STORE THE CHARACTER.
FOUT17: LDA	#0		;A TERMINATOR.
	STA	FBUFFR-1+1,Y
FOUT20: ;LDWDI	FBUFFR
	LDA	#FBUFFR
	LDY	#FBUFFR>>8
	;
FPWRRT: RTS			;ALL DONE.
FHALF:	BYTE	0200	;1/2
	BYTE	0000
ZERO:	BYTE	0000
	BYTE	0000
	BYTE	0

;POWER OF TEN TABLE

FOUTBL: BYTE	0372	;-100,000,000
	BYTE	0012
	BYTE	0037
	BYTE	0000
	BYTE	0000	;10,000,000
	BYTE	0230
	BYTE	0226
	BYTE	0200
	BYTE	0377	;-1,000,000
	BYTE	0360
	BYTE	0275
	BYTE	0300
	BYTE	0000	;100,000
	BYTE	0001
	BYTE	0206
	BYTE	0240
	BYTE	0377	;-10,000
	BYTE	0377
	BYTE	0330
	BYTE	0360
	BYTE	0000	;1000
	BYTE	0000
	BYTE	0003
	BYTE	0350
	BYTE	0377	;-100
	BYTE	0377
	BYTE	0377
	BYTE	0234
	BYTE	0000	;10
	BYTE	0000
	BYTE	0000
	BYTE	0012
	BYTE	0377	;-1
	BYTE	0377
	BYTE	0377
	BYTE	0377
FDCEND:
	;SQUARE ROOT FUNCTION --- SQR(A)
	;USE SQR(X)=X^.5
SQR:	JSR	MOVAF		;MOVE FAC INTO ARG.
	;LDWDI	FHALF
	LDA	#FHALF
	LDY	#FHALF>>8
	;
	JSR	MOVFM		;PUT MEMORY INTO FAC.
				;LAST THING FETCHED IS FACEXP. INTO ACCX.
;	JMP	FPWRT		;FALL INTO FPWRT.

	;EXPONENTIATION ---  X^Y.
	;N.B.  0^0=1
	;FIRST CHECK IF Y=0. IF SO, THE RESULT IS 1.
	;NEXT CHECK IF X=0. IF SO THE RESULT IS 0.
	;THEN CHECK IF X.GT.0. IF NOT CHECK THAT Y IS AN INTEGER.
	;IF SO, NEGATE X, SO THAT LOG DOESN'T GIVE FCERR.
	;IF X IS NEGATIVE AND Y IS ODD, NEGATE THE RESULT
	;RETURNED BY EXP.
	;TO COMPUTE THE RESULT USE X^Y=EXP((Y*LOG(X)).
FPWRT:	BEQ	EXP		;IF FAC=0, JUST EXPONENTIATE THAT.
	LDA	ARGEXP		;IS X=0?
	BNE	FPWRT1
	JMP	ZEROF1		;ZERO FAC.
FPWRT1: ;LDXYI	TEMPF3		;SAVE FOR LATER IN A TEMP.
	LDX	#TEMPF3
	LDY	#TEMPF3>>8
	;
	JSR	MOVMF
	;Y=0 ALREADY. GOOD IN CASE NO ONE CALLS INT.
	LDA	ARGSGN
	BPL	FPWR1		;NO PROBLEMS IF X.GT.0.
	JSR	INT		;INTEGERIZE THE FAC.
	;LDWDI	TEMPF3		;GET ADDR OF COMPERAND.
	LDA	#TEMPF3
	LDY	#TEMPF3>>8
	;
	JSR	FCOMP		;EQUAL?
	BNE	FPWR1		;LEAVE X NEG. LOG WILL BLOW HIM OUT.
				;A=-1 AND Y IS IRRELEVANT.
	TYA			;NEGATE X. MAKE POSITIVE.
	LDY	INTEGR		;GET EVENNESS.
FPWR1:	JSR	MOVFA1		;ALTERNATE ENTRY POINT.
	TYA
	PHA			;SAVE EVENNESS FOR LATER.
	JSR	LOG		;FIND LOG.
	;LDWDI	TEMPF3		;MULTIPLY FAC TIMES LOG(X).
	LDA	#TEMPF3
	LDY	#TEMPF3>>8
	;
	JSR	FMULT
	JSR	EXP		;EXPONENTIATE THE FAC.
	PLA
	LSR	A		;IS IT EVEN?
	BCC	NEGRTS		;YES. OR X.GT.0.
	;NEGATE THE NUMBER IN FAC.
NEGOP:	LDA	FACEXP
	BEQ	NEGRTS
	;COM	FACSGN
	LDA	FACSGN
	EOR	#255
	STA	FACSGN
	;
NEGRTS: RTS

	;FIRST SAVE THE ORIGINAL ARGUMENT AND MULTIPLY THE FAC BY
	;LOG2(E). THE RESULT IS USED TO DETERMINE IF OVERFLOW
	;WILL OCCUR SINCE EXP(X)=2^(X*LOG2(E)) WHERE
	;LOG2(E)=LOG(E) BASE 2. THEN SAVE THE INTEGER PART OF
	;THIS TO SCALE THE ANSWER AT THE END. SINCE
	;2^Y=2^INT(Y)*2^(Y-INT(Y)) AND 2^INT(Y) IS EASY TO COMPUTE.
	;NOW COMPUTE 2^(X*LOG2(E)-INT(X*LOG2(E)) BY
	;P(LN(2)*(INT(X*LOG2(E))+1)-X) WHERE P IS AN APPROXIMATION
	;POLYNOMIAL. THE RESULT IS THEN SCALED BY THE POWER OF 2
	;PREVIOUSLY SAVED.

LOGEB2: BYTE	0201		;LOG(E) BASE 2.
	BYTE	0070
	BYTE	0252
	BYTE	0073
	BYTE	0051

EXPCON: BYTE	7	;DEGREE-1
	BYTE	0161	; .000021498763697
	BYTE	0064
	BYTE	0130
	BYTE	0076
	BYTE	0126
	BYTE	0164	; .00014352314036
	BYTE	0026
	BYTE	0176
	BYTE	0263
	BYTE	0033
	BYTE	0167	; .0013422634824
	BYTE	0057
	BYTE	0356
	BYTE	0343
	BYTE	0205
	BYTE	0172	; .0096140170119
	BYTE	0035
	BYTE	0204
	BYTE	0034
	BYTE	0052
	BYTE	0174	; .055505126860
	BYTE	0143
	BYTE	0131
	BYTE	0130
	BYTE	0012
	BYTE	0176	; .24022638462
	BYTE	0165
	BYTE	0375
	BYTE	0347
	BYTE	0306
	BYTE	0200	; .69314718608
	BYTE	0061
	BYTE	0162
	BYTE	0030
	BYTE	0020
	BYTE	0201	; 1.0
	BYTE	0000
	BYTE	0000
	BYTE	0000
	BYTE	0000

EXP:
	;LDWDI	LOGEB2		;MULTIPLY BY LOG(E) BASE 2.
	LDA	#LOGEB2
	LDY	#LOGEB2>>8
	;
	JSR	FMULT
	LDA	FACOV
	ADC	#0120
	BCC	STOLD
	JSR	INCRND
STOLD:	STA	OLDOV
	JSR	MOVEF		;TO SAVE IN ARG WITHOUT ROUND.
	LDA	FACEXP
	CMP	#0210		;IF ABS(FAC) .GE. 128, TOO BIG.
	BCC	EXP1
GOMLDV: JSR	MLDVEX		;OVERFLOW OR OVERFLOW.
EXP1:	JSR	INT
	LDA	INTEGR	;GET LOW PART.
	CLC
	ADC	#0201
	BEQ	GOMLDV		;OVERFLOW OR OVERFLOW !!
	SEC
	SBC	#1		;SUBTRACT 1.
	PHA			;SAVE A WHILE.
	LDX	#4+ADDPRC	;PREP TO SWAP FAC AND ARG.
SWAPLP: LDA	ARGEXP,X
	LDY	FACEXP,X
	STA	FACEXP,X
	STY	ARGEXP,X
	DEX
	BPL	SWAPLP
	LDA	OLDOV
	STA	FACOV
	JSR	FSUBT
	JSR	NEGOP		;NEGATE FAC.
	;LDWDI	EXPCON
	LDA	#EXPCON
	LDY	#EXPCON>>8
	;
	JSR	POLY
	;CLR	ARISGN		;MULTIPLY BY POSITIVE 1.0.
	LDA	#0
	STA	ARISGN
	;
	PLA			;GET SCALE FACTOR.
	JSR	MLDEXP		;MODIFY FACEXP AND CHECK FOR OVERFLOW.
	RTS			;HAS TO DO JSR DUE TO PULAS IN MULDIV.

	;EVALUATE P(X^2)*X
	;POINTER TO DEGREE IS IN [Y,A].
	;THE CONSTANTS FOLLOW THE DEGREE.
	;FOR X=FAC, COMPUTE:
	; C0*X+C1*X^3+C2*X^5+C3*X^7+...+C(N)*X^(2*N+1)
POLYX:	;STWD	POLYPT		;RETAIN POLYNOMIAL POINTER FOR LATER.
	STA	POLYPT
	STY	POLYPT+1
	;
	JSR	MOV1F		;SAVE FAC IN FACTMP.
	LDA	#TEMPF1
	JSR	FMULT		;COMPUTE X^2.
	JSR	POLY1		;COMPUTE P(X^2).
	;LDWDI	TEMPF1
	LDA	#TEMPF1
	LDY	#TEMPF1>>8
	;
	JMP	FMULT		;MULTIPLY BY FAC AGAIN.

	;POLYNOMIAL EVALUATOR.
	;POINTER TO DEGREE IS IN [Y,A].
	;COMPUTE:
	; C0+C1*X+C2*X^2+C3*X^3+C4*X^4+...+C(N-1)*X^(N-1)+C(N)*X^N.
POLY:	;STWD	POLYPT
	STA	POLYPT
	STY	POLYPT+1
	;
POLY1:	JSR	MOV2F		;SAVE FAC.
	;LDADY	POLYPT
	LDA	(POLYPT),Y
	;
	STA	DEGREE
	LDY	POLYPT
	INY
	TYA
	BNE	POLY3
	INC	POLYPT+1
POLY3:	STA	POLYPT
	LDY	POLYPT+1
POLY2:	JSR	FMULT
	;LDWD	POLYPT		;GET CURRENT POINTER.
	LDA	POLYPT
	LDY	POLYPT+1
	;
	CLC
	ADC	#4+ADDPRC
	BCC	POLY4
	INY
POLY4:	;STWD	POLYPT
	STA	POLYPT
	STY	POLYPT+1
	;
	JSR	FADD		;ADD IN CONSTANT.
	;LDWDI	TEMPF2		;MULTIPLY THE ORIGINAL FAC.
	LDA	#TEMPF2
	LDY	#TEMPF2>>8
	;
	DEC	DEGREE		;DONE?
	BNE	POLY2
RANDRT: RTS			;YES.

	;PSUEDO-RANDOM NUMBER GENERATOR.
	;IF ARG=0, THE LAST RANDOM NUMBER GENERATED IS RETURNED.
	;IF ARG .LT. 0, A NEW SEQUENCE OF RANDOM NUMBERS IS
	;STARTED USING THE ARGUMENT.
	;   TO FORM THE NEXT RANDOM NUMBER IN THE SEQUENCE,
	;MULTIPLY THE PREVIOUS RANDOM NUMBER BY A RANDOM CONSTANT
	;AND ADD IN ANOTHER RANDOM CONSTANT. THE THEN HO
	;AND LO BYTES ARE SWITCHED, THE EXPONENT IS PUT WHERE
	;IT WILL BE SHIFTED IN BY NORMAL, AND THE EXPONENT IN THE FAC
	;IS SET TO 200 SO THE RESULT WILL BE LESS THAN 1. THIS
	;IS THEN NORMALIZED AND SAVED FOR THE NEXT TIME.
	;THE HO AND LOW BYTES WERE SWITCHED SO THERE WILL BE A
	;RANDOM CHANCE OF GETTING A NUMBER LESS THAN OR GREATER
	;THAN .5 .

RMULZC: BYTE	0230
	BYTE	0065
	BYTE	0104
	BYTE	0172
RADDZC: BYTE	0150
	BYTE	0050
	BYTE	0261
	BYTE	0106

RND:	JSR	SIGN		;GET SIGN INTO ACCX.
	TAX			;GET INTO ACCX, SINCE "MOVFM" USES ACCX.
	BMI	RND1		;START NEW SEQUENCE IF NEGATIVE.
QSETNR: ;LDWDI	RNDX		;GET LAST ONE INTO FAC.
	LDA	#RNDX
	LDY	#RNDX>>8
	;
	JSR	MOVFM
	TXA			;FAC WAS ZERO?
	BEQ	RANDRT		;RESTORE LAST ONE.
	;LDWDI	RMULZC		;MULTIPLY BY RANDOM CONSTANT.
	LDA	#RMULZC
	LDY	#RMULZC>>8
	;
	JSR	FMULT
	;LDWDI	RADDZC
	LDA	#RADDZC
	LDY	#RADDZC>>8
	;
	JSR	FADD		;ADD RANDOM CONSTANT.
RND1:	LDX	FACLO
	LDA	FACHO
	STA	FACLO
	STX	FACHO		;REVERSE HO AND LO.
STRNEX: ;CLR	FACSGN		;MAKE NUMBER POSITIVE.
	LDA	#0
	STA	FACSGN
	;
	LDA	FACEXP		;PUT EXP WHERE IT WILL
	STA	FACOV		;BE SHIFTED IN BY NORMAL.
	LDA	#0200
	STA	FACEXP		;MAKE RESULT BETWEEN 0 AND 1.
	JSR	NORMAL		;NORMALIZE.
	;LDXYI	RNDX
	LDX	#RNDX
	LDY	#RNDX>>8
	;
GMOVMF: JMP	MOVMF		;PUT NEW ONE INTO MEMORY.

	;COSINE FUNCTION.
	;USE COS(X)=SIN(X+PI/2)
COS:	;LDWDI	PI2		;PNTR TO PI/2.
	LDA	#PI2
	LDY	#PI2>>8
	;
	JSR	FADD		;ADD IT IN.
				;FALL INTO SIN.


	;SINE FUNCTION.
	;USE IDENTITIES TO GET FAC IN QUADRANTS I OR IV.
	;THE FAC IS DIVIDED BY 2*PI AND THE INTEGER PART IS IGNORED
	;BECAUSE SIN(X+2*PI)=SIN(X). THEN THE ARGUMENT CAN BE COMPARED
	;WITH PI/2 BY COMPARING THE RESULT OF THE DIVISION
	;WITH PI/2/(2*PI)=1/4.
	;IDENTITIES ARE THEN USED TO GET THE RESULT IN QUADRANTS
	;I OR IV. AN APPROXIMATION POLYNOMIAL IS THEN USED TO
	;COMPUTE SIN(X).
SIN:	JSR	MOVAF
	;LDWDI	TWOPI		;GET PNTR TO DIVISOR.
	LDA	#TWOPI
	LDY	#TWOPI>>8
	;
	LDX	ARGSGN		;GET SIGN OF RESULT.
	JSR	FDIVF
	JSR	MOVAF		;GET RESULT INTO ARG.
	JSR	INT		;INTEGERIZE FAC.
	;CLR	ARISGN		;ALWAYS HAVE THE SAME SIGN.
	LDA	#0
	STA	ARISGN
	;
	JSR	FSUBT		;KEEP ONLY THE FRACTIONAL PART.
	;LDWDI	FR4		;GET PNTR TO 1/4.
	LDA	#FR4
	LDY	#FR4>>8
	;
	JSR	FSUB		;COMPUTE 1/4-FAC.
	LDA	FACSGN		;SAVE SIGN FOR LATER.
	PHA
	BPL	SIN1		;FIRST QUADRANT.
	JSR	FADDH		;ADD 1/2 TO FAC.
	LDA	FACSGN		;SIGN IS NEGATIVE?
	BMI	SIN2
	;COM	TANSGN		;QUADRANTS II AND III COME HERE.
	LDA	TANSGN
	EOR	#255
	STA	TANSGN
	;
SIN1:	JSR	NEGOP		;IF POSITIVE, NEGATE IT.
SIN2:	;LDWDI	FR4		;POINTER TO 1/4.
	LDA	#FR4
	LDY	#FR4>>8
	;
	JSR	FADD		;ADD IT IN.
	PLA			;GET ORIGINAL QUADRANT.
	BPL	SIN3
	JSR	NEGOP		;IF NEGATIVE, NEGATE RESULT.
SIN3:	;LDWDI	SINCON
	LDA	#SINCON
	LDY	#SINCON>>8
	;
GPOLYX: JMP	POLYX		;DO APPROXIMATION POLYNOMIAL.


	;TANGENT FUNCTION.
TAN:	JSR	MOV1F		;MOVE FAC INTO TEMPORARY.
	;CLR	TANSGN		;REMEMBER WHETHER TO NEGATE.
	LDA	#0
	STA	TANSGN
	;
	JSR	SIN		;COMPUTE THE SIN.
	;LDXYI	TEMPF3
	LDX	#TEMPF3
	LDY	#TEMPF3>>8
	;
	JSR	GMOVMF		;PUT SIGN INTO OTHER TEMP.
	;LDWDI	TEMPF1
	LDA	#TEMPF1
	LDY	#TEMPF1>>8
	;
	JSR	MOVFM		;PUT THIS MEMORY LOC INTO FAC.
	;CLR	FACSGN		;START OFF POSITIVE.
	LDA	#0
	STA	FACSGN
	;
	LDA	TANSGN
	JSR	COSC		;COMPUTE COSINE.
	;LDWDI	TEMPF3		;ADDRESS OF SINE VALUE.
	LDA	#TEMPF3
	LDY	#TEMPF3>>8
	;
GFDIV:	JMP	FDIV		;DIVIDE SINE BY COSINE AND RETURN.
COSC:	PHA
	JMP	SIN1

PI2:	BYTE	0201	;PI/2
	BYTE	0111
	BYTE	0017
	BYTE	0333-ADDPRC
	BYTE	0242
TWOPI:	BYTE	0203	;2*PI.
	BYTE	0111
	BYTE	0017
	BYTE	0333-ADDPRC
	BYTE	0242
FR4:	BYTE	0177	;1/4
	BYTE	0000
	BYTE	0000
	BYTE	0000
	BYTE	0

SINCON: BYTE	5		;DEGREE-1.
	BYTE	0204	; -14.381383816
	BYTE	0346
	BYTE	0032
	BYTE	0055
	BYTE	0033
	BYTE	0206	; 42.07777095
	BYTE	0050
	BYTE	0007
	BYTE	0373
	BYTE	0370
	BYTE	0207	; -76.704133676
	BYTE	0231
	BYTE	0150
	BYTE	0211
	BYTE	0001
	BYTE	0207	; 81.605223690
	BYTE	0043
	BYTE	0065
	BYTE	0337
	BYTE	0341
	BYTE	0206	; -41.34170209
	BYTE	0245
	BYTE	0135
	BYTE	0347
	BYTE	0050
	BYTE	0203	; 6.2831853070
	BYTE	0111
	BYTE	0017
	BYTE	0332
	BYTE	0242
	BYTE	0241	; 7.2362932E7
	BYTE	0124
	BYTE	0106
	BYTE	0217
	BYTE	0023
	BYTE	0217	; 73276.2515
	BYTE	0122
	BYTE	0103
	BYTE	0211
	BYTE	0315
	;USE IDENTITIES TO GET ARG BETWEEN 0 AND 1 AND THEN USE AN
	;APPROXIMATION POLYNOMIAL TO COMPUTE ARCTAN(X).
ATN:	LDA	FACSGN		;WHAT IS SIGN?
	PHA			;(MEANWHILE SAVE FOR LATER.)
	BPL	ATN1
	JSR	NEGOP		;IF NEGATIVE, NEGATE FAC.
				;USE ARCTAN(X)=-ARCTAN(-X) .
ATN1:	LDA	FACEXP
	PHA			;SAVE THIS TOO FOR LATER.
	CMP	#0201		;SEE IF FAC .GE. 1.0 .
	BCC	ATN2		;IT IS LESS THAN 1.
	;LDWDI	FONE		;GET PNTR TO 1.0 .
	LDA	#FONE
	LDY	#FONE>>8
	;
	JSR	FDIV		;COMPUTE RECIPROCAL.
				;USE ARCTAN(X)=PI/2-ARCTAN(1/X) .
ATN2:	;LDWDI	ATNCON		;PNTR TO ARCTAN CONSTANTS.
	LDA	#ATNCON
	LDY	#ATNCON>>8
	;
	JSR	POLYX
	PLA
	CMP	#0201		;WAS ORIGINAL ARGUMENT .LT. 1 ?
	BCC	ATN3		;YES.
	;LDWDI	PI2
	LDA	#PI2
	LDY	#PI2>>8
	;
	JSR	FSUB		;SUBTRACT ARCTAGN FROM PI/2.
ATN3:	PLA			;WAS ORIGINAL ARGUMENT POSITIVE?
	BPL	ATN4		;YES.
	JMP	NEGOP		;IF NEGATIVE, NEGATE RESULT.
ATN4:	RTS			;ALL DONE.

ATNCON: BYTE	0013	;DEGREE-1.
	BYTE	0166	; -.0006847939119
	BYTE	0263
	BYTE	0203
	BYTE	0275
	BYTE	0323
	BYTE	0171	; .004850942156
	BYTE	0036
	BYTE	0364
	BYTE	0246
	BYTE	0365
	BYTE	0173	; -.01611170184
	BYTE	0203
	BYTE	0374
	BYTE	0260
	BYTE	0020
	BYTE	0174	; .03420963805
	BYTE	0014
	BYTE	0037
	BYTE	0147
	BYTE	0312
	BYTE	0174	; -.05427913276
	BYTE	0336
	BYTE	0123
	BYTE	0313
	BYTE	0301
	BYTE	0175	; .07245719654
	BYTE	0024
	BYTE	0144
	BYTE	0160
	BYTE	0114
	BYTE	0175	; -.08980239538
	BYTE	0267
	BYTE	0352
	BYTE	0121
	BYTE	0172
	BYTE	0175	; .1109324134
	BYTE	0143
	BYTE	0060
	BYTE	0210
	BYTE	0176
	BYTE	0176	; -.1428398077
	BYTE	0222
	BYTE	0104
	BYTE	0231
	BYTE	0072
	BYTE	0176	; .1999991205
	BYTE	0114
	BYTE	0314
	BYTE	0221
	BYTE	0307
	BYTE	0177	; -.3333333157
	BYTE	0252
	BYTE	0252
	BYTE	0252
	BYTE	0023
	BYTE	0201	; 1.0
	BYTE	0000
	BYTE	0000
	BYTE	0000
	BYTE	0000
;RADIX	10		;IN ALL NON-MATH-PACKAGE CODE.
; THIS INITIALIZES THE BASIC INTERPRETER FOR THE M6502 AND SHOULD BE
; LOCATED WHERE IT WILL BE WIPED OUT IN RAM IF CODE IS ALL IN RAM.

INITAT: INC	CHRGET+7	;INCREMENT THE WHOLE TXTPTR.
	BNE	CHZGOT
	INC	CHRGET+8
CHZGOT: LDA	60000		;A LOAD WITH AN EXT ADDR.
	CMP	#":"		;IS IT A ":"?
	BCS	CHZRTS		;IT IS .GE. ":"
	CMP	#" "		;SKIP SPACES.
	BEQ	INITAT
	SEC
	SBC	#"0"		;ALL CHARS .GT. "9" HAVE RET'D SO
	SEC
	SBC	#256-"0"	;SEE IF NUMERIC.
				;TURN CARRY ON IF NUMERIC.
				;ALSO, SETZ IF NULL.
CHZRTS: RTS			;RETURN TO CALLER.

	BYTE	128		;LOADED OR FROM ROM.
	BYTE	79		;THE INITIAL RANDOM NUMBER.
	BYTE	199
	BYTE	82
	BYTE	88
TYPAUT: ;LDWDI	AUTTXT
	LDA	#AUTTXT
	LDY	#AUTTXT>>8
	;
	JSR	STROUT
INIT:
	LDX	#255		;MAKE IT LOOK DIRECT IN CASE OF
	STX	CURLIN+1	;ERROR MESSAGE.
	LDX	#STKEND-256
	TXS
	;LDWDI	INIT		;ALLOW RESTART.
	LDA	#INIT
	LDY	#INIT>>8
	;
	;STWD	START+1
	STA	START+1
	STY	START+2
	;
	;STWD	RDYJSR+1	;RTS HERE ON ERRORS.
	STA	RDYJSR+1
	STY	RDYJSR+2
	;
	;LDWDI	AYINT
	LDA	#AYINT
	LDY	#AYINT>>8
	;
	;STWD	ADRAYI
	STA	ADRAYI
	STY	ADRAYI+1
	;
	;LDWDI	GIVAYF
	LDA	#GIVAYF
	LDY	#GIVAYF>>8
	;
	;STWD	ADRGAY
	STA	ADRGAY
	STY	ADRGAY+1
	;
	LDA	#76		;JMP INSTRUCTION.
	STA	START
	STA	RDYJSR
	STA	JMPER
	STA	USRPOK
	;LDWDI	FCERR
	LDA	#FCERR
	LDY	#FCERR>>8
	;
	;STWD	USRPOK+1
	STA	USRPOK+1
	STY	USRPOK+2
	;
	LDA	#LINLEN		;THESE MUST BE NON-ZERO SO CHEAD WILL
	STA	LINWID		;WORK AFTER MOVING A NEW LINE IN BUF
				;INTO THE PROGRAM
	LDA	#NCMPOS
	STA	NCMWID
	LDX	#RNDX+4-CHRGET
MOVCHG: LDA	INITAT-1,X
	STA	CHRGET-1,X	;MOVE TO RAM.
	DEX
	BNE	MOVCHG
	LDA	#STRSIZ
	STA	FOUR6
	TXA			;SET CONST IN RAM.
	STA	BITS
	STA	LASTPT+1
	PHA			;PUT ZERO AT THE END OF THE STACK
				;SO FNDFOR WILL STOP
	STA	CNTWFL		;BE TALKATIVE.
	INX			;MAKE [X]=1
	STX	BUF-3		;SET PRE-BUF BYTES NON-ZERO FOR CHEAD
	STX	BUF-4
	JSR	CRDO		;TYPE A CR.
	LDX	#TEMPST
	STX	TEMPPT		;SET UP STRING TEMPORARIES.
	;LDWDI	MEMORY
	LDA	#MEMORY
	LDY	#MEMORY>>8
	;
	JSR	STROUT
	JSR	QINLIN		;GET A LINE OF INPUT.
	;STXY	TXTPTR		;READ THIS !
	STX	TXTPTR
	STY	TXTPTR+1
	;
	JSR	CHRGET		;GET THE FIRST CHARACTER.
	CMP	#"A"		;IS IT AN "A"?
	BEQ	TYPAUT		;YES TYPE AUTHOR'S NAME.
	TAY			;NULL INPUT?
	BNE	USEDE9		;NO.
	;LDWDI	RAMLOC
	LDA	#RAMLOC
	LDY	#RAMLOC>>8
	;
	;STWD	TXTTAB		;SET UP START OF PROGRAM LOCATION
	STA	TXTTAB
	STY	TXTTAB+1
	;
;;;	;STWD	LINNUM
;;;	STA	LINNUM
;;;	STY	LINNUM+1
;;;	;
;;;	LDY	#0
;;;LOOPMM: INC	LINNUM
;;;	BNE	LOOPM1
;;;	INC	LINNUM+1
;;;LOOPM1: LDA	#85		;PUT RANDOM INFO INTO MEM.
;;;	;STADY	LINNUM
;;;	STA	(LINNUM),Y
;;;	;
;;;	;CMPDY	LINNUM		;WAS IT SAVED?
;;;	CMP	(LINNUM),Y
;;;	;
;;;	BNE	USEDEC		;NO. THAT IS END OF MEMORY.
;;;	ASL	A		;LOOKS LIKE IT. TRY ANOTHER.
;;;	;STADY	LINNUM
;;;	STA	(LINNUM),Y
;;;	;
;;;	;CMPDY	LINNUM		;WAS IT SAVED?
;;;	CMP	(LINNUM),Y
;;;	;
;;;	BNE	USEDEC		;NO. THIS IS THE END.
;;;	BEQ	LOOPMM
	LDA	#ROMLOC		;;;
	STA	LINNUM		;;;
	LDA	#ROMLOC>>8	;;;
	STA	LINNUM+1	;;;
	JMP	USEDEC		;;;

USEDE9: JSR	CHRGOT		;GET CURRENT CHARACTER.
	JSR	LINGET		;GET DECIMAL ARGUMENT.
	TAY			;MAKE SURE A TERMINATOR EXISTS.
	BEQ	USEDEC		;IT DOES.
	JMP	SNERR		;IT DOESN'T.
USEDEC: ;LDWD	LINNUM		;GET SIZE OF MEMORY INPUT.
	LDA	LINNUM
	LDY	LINNUM+1
	;
USEDEF:				;HIGHEST ADDRESS.
	;STWD	MEMSIZ		;THIS IS THE SIZE OF MEMORY.
	STA	MEMSIZ
	STY	MEMSIZ+1
	;
	;STWD	FRETOP		;TOP OF STRINGS TOO.
	STA	FRETOP
	STY	FRETOP+1
	;
TTYW:
	;LDWDI	TTYWID
	LDA	#TTYWID
	LDY	#TTYWID>>8
	;
	JSR	STROUT
	JSR	QINLIN		;GET LINE OF INPUT.
	;STXY	TXTPTR		;READ THIS !
	STX	TXTPTR
	STY	TXTPTR+1
	;
	JSR	CHRGET		;GET FIRST CHARACTER.
	TAY			;TEST ACCA BUT DON'T AFFECT CARRY.
	BEQ	ASKAGN
	JSR	LINGET		;GET ARGUMENT.
	LDA	LINNUM+1
	BNE	TTYW		;WIDTH MUST BE .LT. 256.
	LDA	LINNUM
	CMP	#16		;WIDTH MUST BE GREATER THAN 16.
	BCC	TTYW
	STA	LINWID		;THAT IS THE LINE WIDTH.
MORCPS: SBC	#CLMWID		;COMPUTE POSITION BEYOND WHICH
	BCS	MORCPS		;THERE ARE NO MORE FIELDS.
	EOR	#255
	SBC	#CLMWID-2
	CLC
	ADC	LINWID
	STA	NCMWID
ASKAGN:
	;LDXYI	RAMLOC
	LDX	#RAMLOC
	LDY	#RAMLOC>>8
	;
	;STXY	TXTTAB
	STX	TXTTAB
	STY	TXTTAB+1
	;
	LDY	#0
	TYA
	;STADY	TXTTAB		;SET UP TEXT TABLE.
	STA	(TXTTAB),Y
	;
	INC	TXTTAB
	BNE	QROOM
	INC	TXTTAB+1
QROOM:	;LDWD	TXTTAB		;PREPARE TO USE "REASON".
	LDA	TXTTAB
	LDY	TXTTAB+1
	;
	JSR	REASON
	JSR	CRDO
	LDA	MEMSIZ		;COMPUTE [MEMSIZ]-[VARTAB].
	SEC
	SBC	TXTTAB
	TAX
	LDA	MEMSIZ+1
	SBC	TXTTAB+1
	JSR	LINPRT		;TYPE THIS VALUE.
	;LDWDI	WORDS		;MORE BULLSHIT.
	LDA	#WORDS
	LDY	#WORDS>>8
	;
	JSR	STROUT
	JSR	SCRTCH		;SET UP EVERYTHING ELSE.
	;LDWDI	STROUT
	LDA	#STROUT
	LDY	#STROUT>>8
	;
	;STWD	RDYJSR+1
	STA	RDYJSR+1
	STY	RDYJSR+2
	;
	;LDWDI	READY
	LDA	#READY
	LDY	#READY>>8
	;
	;STWD	START+1
	STA	START+1
	STY	START+2
	;
	;JMPD	START+1
	JMP	(START+1)
	;

AUTTXT:	BYTE	13,10
	BYTE	10			;ANOTHER LINE FEED.
	BYTE	"WRITTEN "
	BYTE	"BY WEILAND & GATES"
	BYTE	13,10
	BYTE	0
MEMORY: BYTE	"MEMORY SIZE"
	BYTE	0
TTYWID: BYTE	"TERMINAL WIDTH"
	BYTE	0
WORDS:	BYTE	" BYTES FREE"
	BYTE	13,10
	BYTE	13,10
	BYTE	"COPYRIGHT 1978 MICROSOFT"
	BYTE	13,10
	BYTE	0
LASTWR:
